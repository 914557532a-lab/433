C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DISPLAYPROCESS
OBJECT MODULE PLACED IN .\FileOutput\DisplayProcess.obj
COMPILER INVOKED BY: D:\software\keil\C51\BIN\C51.EXE SourceFile\DisplayProcess.C LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE IN
                    -CDIR(.\ConfigFile;.\CMT2300A) DEBUG PRINT(.\FileOutput\DisplayProcess.lst) TABS(2) OBJECT(.\FileOutput\DisplayProcess.ob
                    -j)

line level    source

   1          //-----------------------------------------------------------------------------
   2          //功能说明：风暖面板，显示数据更新
   3          //创建日期：
   4          //-----------------------------------------------------------------------------
   5          #include <intrins.h>
   6          #include "ca51f_config.h"
   7          #include "ca51f2sfr.h"
   8          #include "ca51f2xsfr.h"
   9          #include "gpiodef_f2.h"
  10          #include "system.h"
  11          
  12          //-----------------------------------------------------------------------------
  13          #include "flash.h"
  14          #include "WT588Fxx.h"
  15          
  16          #include "LCD_DRIVER.H"
  17          #include "RTC_DRVIER.H"
  18          #include "KeyEvent.H"
  19          #include "UART2_ISR.h"
  20          #include "HP_03N_DRV.H"
  21          #include "DisplayUpdata.H"
  22          
  23          #ifdef Enable_CMT2300 //打开双向遥控
  24            #include "Radio.H"
  25          #endif
  26          
  27          #include "RF_Receiver.H"
  28          //---- 笔段排列顺序 --- 0 -- 7 == C G B   D E F A
  29          //-----------------------------------0----1----2----3----4----5----6----7----8----9-----------
  30          unsigned char code LCD_NUM_CODE[]={0xF5,0x05,0xB6,0x97,0x47,0xD3,0xF3,0x85,0xF7,0xD7,\
  31          //-----------------------------------H----F----o----N----O----C----P----U----E--  -  ---------
  32                             0x67,0xE2,0x33,0xE5,0xC6,0xF0,0xE6,0x75,0xF2,0x02,\
  33          //-----------------------------------A ---L---
  34                             0xE7,0x70};
  35          //-----------------------------------------------------------------------------
  36          xdata unsigned int BackLightTime;
  37          xdata unsigned char DisplayIndex;
  38          xdata unsigned char DisplaySetIndex;
  39          xdata unsigned char DisplayStateIndex;
  40          xdata unsigned char FlashDisplayTime;
  41          /////
  42          xdata unsigned char Fan_DisplayTime;
  43          xdata unsigned char Fan_DisplayHold;
  44          
  45          xdata unsigned char Fan_DisplayIndex;
  46          //////
  47          xdata unsigned char SystemRunIndex;
  48          xdata unsigned char SystemRunState;
  49          //////
  50          xdata unsigned char SystemStateTime;
  51          xdata unsigned char SystemStateHold;
  52          ////////////////////////////////////////////////////////////////
  53          #define MainPassword  0x9009//超级密码
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 2   

  54          xdata unsigned int InputPassword;
  55          
  56          //////
  57          xdata union{
  58            unsigned char Array[2];
  59            unsigned int Data;
  60          }RunVoltage;
  61          ////////////////////////////////////////////////////////////////
  62          xdata union{
  63            unsigned char TempArray[2];
  64            signed int Temperature;
  65          }SW;
  66          xdata union{
  67            unsigned char TempArray[2];
  68            signed int Temperature;
  69          }HY;
  70          xdata union{
  71            unsigned char Array[2];
  72            unsigned int Data;
  73          }RotateSpeed;
  74          xdata union{
  75            unsigned char Array[2];
  76            unsigned int Data;
  77          }Set_Speed;
  78          xdata union{
  79              unsigned char Array[2];
  80            unsigned int Data;
  81          }Fan_Vot;
  82          xdata union{
  83              unsigned int DutyCycle;
  84              unsigned char Data[2];
  85          }Ignition_Vot;
  86          xdata union{
  87              unsigned int Current;
  88              unsigned char Data[2];
  89          }Ignition_CUR;
  90          
  91          xdata union{
  92              unsigned char Array[2];
  93            unsigned int Data;
  94          }WaterPump_CUR;
  95          xdata unsigned char ErrorIndex;
  96          xdata unsigned char ErrorIndexHold;
  97          xdata unsigned char SetupTemperatureHold;
  98          
  99          xdata unsigned char OilpumpSetFrequ;//油泵设定频率
 100          xdata unsigned char OilPumpFrequency;//油泵频率
 101          xdata unsigned char WorkingTime;//剩余工作时间
 102          xdata unsigned char RemainingWorkingTime;//剩余工作时间
 103          //-----------------------------------------------------------------------------
 104          xdata union{
 105            unsigned char DATA;
 106            struct{
 107              unsigned char BIT_1:1;//喇叭 图标
 108              unsigned char BIT_2:1;//海拔高度 m
 109              unsigned char BIT_3:1;//加热图标
 110              unsigned char BIT_4:1;//故障图标
 111              unsigned char BIT_5:1;//油箱图标
 112              unsigned char BIT_6:1;//转速 RPM
 113              unsigned char BIT_7:1;//电压单位 V
 114              unsigned char BIT_8:1;//百分比 %
 115            }BIT;
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 3   

 116          }LCD_00;//第一行，第一个8字
 117          xdata union{
 118            unsigned char DATA;
 119            struct{
 120              unsigned char BIT_1:1;//1C
 121              unsigned char BIT_2:1;//1G
 122              unsigned char BIT_3:1;//1B
 123              unsigned char BIT_4:1;//Hz
 124              unsigned char BIT_5:1;//1D
 125              unsigned char BIT_6:1;//1E
 126              unsigned char BIT_7:1;//1F
 127              unsigned char BIT_8:1;//1A
 128            }BIT;
 129          }LCD_01;//第二行，第二个8字
 130          xdata union{
 131            unsigned char DATA;
 132            struct{
 133              unsigned char BIT_1:1;//2C
 134              unsigned char BIT_2:1;//2G
 135              unsigned char BIT_3:1;//2B
 136              unsigned char BIT_4:1;//第3位 下点
 137              unsigned char BIT_5:1;//2D
 138              unsigned char BIT_6:1;//2E
 139              unsigned char BIT_7:1;//2F
 140              unsigned char BIT_8:1;//2A
 141            }BIT;
 142          }LCD_02;//第二行，第二个8字
 143          xdata union{
 144            unsigned char DATA;
 145            struct{
 146              unsigned char BIT_1:1;//第2位 下点
 147              unsigned char BIT_2:1;//秒点
 148              unsigned char BIT_3:1;//电池图标
 149              unsigned char BIT_4:1;//第3位 上点
 150              unsigned char BIT_5:1;//飘带 10   电源-右下角
 151              unsigned char BIT_6:1;//飘带 9 
 152              unsigned char BIT_7:1;//飘带 8
 153              unsigned char BIT_8:1;//飘带 7
 154            }BIT;
 155          }LCD_03;//第二行，第一个8字
 156          xdata union{
 157            unsigned char DATA;
 158            struct{
 159              unsigned char BIT_1:1;//飘带 3    箭头-右下角
 160              unsigned char BIT_2:1;//飘带 4    
 161              unsigned char BIT_3:1;//飘带 5
 162              unsigned char BIT_4:1;//飘带 6
 163              unsigned char BIT_5:1;//关机 图标
 164              unsigned char BIT_6:1;//飘带 2
 165              unsigned char BIT_7:1;//飘带 线条
 166              unsigned char BIT_8:1;//飘带 1
 167            }BIT;
 168          }LCD_04;//第三行，第一个8字
 169          xdata union{
 170            unsigned char DATA;
 171            struct{
 172              unsigned char BIT_1:1;//下调 图标
 173              unsigned char BIT_2:1;//闹钟图标
 174              unsigned char BIT_3:1;//AT 图标
 175              unsigned char BIT_4:1;//MT 图标
 176              unsigned char BIT_5:1;//上调 图标
 177              unsigned char BIT_6:1;//断线 图标
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 4   

 178              unsigned char BIT_7:1;//温度传感器 图标
 179              unsigned char BIT_8:1;//点火塞 图标
 180            }BIT;
 181          }LCD_05;//第四行，第二个8字
 182          xdata union{
 183            unsigned char DATA;
 184            struct{
 185              unsigned char BIT_1:1;//扇叶 1
 186              unsigned char BIT_2:1;//扇叶 中点
 187              unsigned char BIT_3:1;//扇叶 2
 188              unsigned char BIT_4:1;//设置 图标
 189              unsigned char BIT_5:1;//油泵 图标
 190              unsigned char BIT_6:1;//水泵 图标
 191              unsigned char BIT_7:1;//扇叶 4
 192              unsigned char BIT_8:1;//扇叶 3
 193            }BIT;
 194          }LCD_06;//第四行，第一个8字
 195          xdata union{
 196            unsigned char DATA;
 197            struct{
 198              unsigned char BIT_1:1;//天线 主线
 199              unsigned char BIT_2:1;//天线 1
 200              unsigned char BIT_3:1;//天线 2
 201              unsigned char BIT_4:1;//天线 3
 202              unsigned char BIT_5:1;//4D
 203              unsigned char BIT_6:1;//4E
 204              unsigned char BIT_7:1;//4F
 205              unsigned char BIT_8:1;//4A
 206            }BIT;
 207          }LCD_07;//第五行，第一个8字
 208          xdata union{
 209            unsigned char DATA;
 210            struct{
 211              unsigned char BIT_1:1;//4C
 212              unsigned char BIT_2:1;//4G
 213              unsigned char BIT_3:1;//4B
 214              unsigned char BIT_4:1;//天线 4
 215              unsigned char BIT_5:1;//3D
 216              unsigned char BIT_6:1;//3E
 217              unsigned char BIT_7:1;//3F
 218              unsigned char BIT_8:1;//3A
 219            }BIT;
 220          }LCD_08;//第五行，第一个8字
 221          xdata union{
 222            unsigned char DATA;
 223            struct{
 224              unsigned char BIT_1:1;//3C
 225              unsigned char BIT_2:1;//3G
 226              unsigned char BIT_3:1;//3B
 227              unsigned char BIT_4:1;//海拔高度 图标
 228              unsigned char BIT_5:1;//
 229              unsigned char BIT_6:1;//
 230              unsigned char BIT_7:1;//
 231              unsigned char BIT_8:1;//
 232            }BIT;
 233          }LCD_09;//第五行，第一个8字
 234          //10101010  
 235          //-----------------------------------------------------------------------------
 236          void ClearDisplay(void)
 237          { LCD_00.DATA = 0x00;
 238   1        LCD_01.DATA = 0x00;
 239   1        LCD_02.DATA = 0x00;
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 5   

 240   1        LCD_03.DATA = 0x00;
 241   1        LCD_04.DATA = 0x00;
 242   1        LCD_05.DATA = 0x00;
 243   1        LCD_06.DATA = 0x00;
 244   1        LCD_07.DATA = 0x00;
 245   1        LCD_08.DATA = 0x00;
 246   1      }
 247          //-----------------------------------------------------------------------------
 248          void ClearBitDisplay(void)
 249          {
 250   1        LCD_00.DATA &= 0x1D;  //0001 1011
 251   1        LCD_00.BIT.BIT_3 = EQUAL_L;//水暖图标
 252   1        LCD_01.BIT.BIT_4 = EQUAL_L;//Hz 图标
 253   1        LCD_02.BIT.BIT_4 = EQUAL_L;//第3位 下点
 254   1        LCD_03.BIT.BIT_1 = EQUAL_L;//第2位 下点
 255   1        LCD_03.BIT.BIT_2 = EQUAL_L;//秒点
 256   1        LCD_03.BIT.BIT_4 = EQUAL_L;//第3位 上点
 257   1        LCD_06.BIT.BIT_4 = EQUAL_L;//设置 图标
 258   1        LCD_09.BIT.BIT_4 = EQUAL_L;//海拔高度
 259   1        
 260   1      
 261   1      }
 262          //-----------------------------------------------------------------------------
 263          void DisplayDataInitial(void)
 264          { ClearDisplay();//清除全部显示
 265   1      //----------------------------------------------------------
 266   1        ErrorIndex = 0x00;
 267   1        UART_ERROR_Time = 100;//通信错误故障
 268   1        
 269   1        WorkingTime = 45;//预热时间默认45分钟
 270   1      
 271   1        RunVoltage.Data = 0x0000;
 272   1        Fan_Vot.Data = 0x0000;
 273   1        RotateSpeed.Data = 0x0000;
 274   1      
 275   1        Ignition_Vot.DutyCycle = 0x0000;
 276   1        Ignition_CUR.Current = 0x0000;
 277   1      
 278   1        OilPumpFrequency = 0x00;
 279   1      
 280   1        SW.Temperature = 0x0000;
 281   1        HY.Temperature = 0x0000;
 282   1        WaterPump_CUR.Data = 0x0000;
 283   1      //----------------------------------------------------------
 284   1        SystemRunIndex = 0x00;//运行状态
 285   1        SystemStateHold = SystemRunState;
 286   1      //----------------------------------------------------------
 287   1        Fan_DisplayIndex = 0x00;
 288   1      
 289   1        DisplayIndex  = 0x00;
 290   1        DisplaySetIndex = 0x09;//从读取参数开始
 291   1        DisplayStateIndex = 0x00;
 292   1        System.BIT.BIT_04 = EQUAL_L;//清除 密码更新状态
 293   1        
 294   1        //----------------------------------------------------------
 295   1      //  Config.Struct.RF_ModeSelect = Select_OneWay_RF;
 296   1      
 297   1      }
 298          //-----------------------------------------------------------------------------
 299          //#pragma optimize(0)
 300          //-----------------------------------------------------------------------------
 301          
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 6   

 302          void Number_1_Display(unsigned char Type,unsigned char Number)
 303          { LCD_07.DATA &= 0x0F;
 304   1        LCD_08.DATA &= 0xF8;//默认千位数字关闭
 305   1        //--------------------------------------
 306   1        switch(Type)
 307   1        {case 0x02:
 308   2            if(FlashDisplayTime >10)//秒闪
 309   2            { break;    }
 310   2         case 0x01:
 311   2            LCD_07.DATA |= (LCD_NUM_CODE[Number] &0xF0);
 312   2            LCD_08.DATA |= (LCD_NUM_CODE[Number] &0x07);
 313   2          break;
 314   2        }
 315   1      }
 316          void Number_2_Display(unsigned char Type,unsigned char Number)
 317          { LCD_08.DATA &= 0x0F;
 318   1        LCD_09.DATA &= 0xF8;//默认百位数字关闭
 319   1        //--------------------------------------
 320   1        switch(Type)
 321   1        {case 0x02:
 322   2            if(FlashDisplayTime >10)//秒闪
 323   2            { break;    }
 324   2         case 0x01:
 325   2            LCD_08.DATA |= (LCD_NUM_CODE[Number] &0xF0);
 326   2            LCD_09.DATA |= (LCD_NUM_CODE[Number] &0x07);
 327   2          break;
 328   2        }
 329   1      }
 330          
 331          void Number_3_Display(unsigned char Type,unsigned char Number)
 332          { LCD_02.DATA &= 0x08;//默认十位数字关闭
 333   1        //--------------------------------------
 334   1        switch(Type)
 335   1        {case 0x02:
 336   2            if(FlashDisplayTime >10)//秒闪
 337   2            { break;    }
 338   2         case 0x01:
 339   2            LCD_02.DATA |= LCD_NUM_CODE[Number];
 340   2          break;
 341   2        }
 342   1      }
 343          void Number_4_Display(unsigned char Type,unsigned char Number)
 344          { LCD_01.DATA &= 0x08;//默认个位数字关闭
 345   1        //--------------------------------------
 346   1        switch(Type)
 347   1        {case 0x02:
 348   2            if(FlashDisplayTime >10)//秒闪
 349   2            { break;    }
 350   2         case 0x01:
 351   2            LCD_01.DATA |= LCD_NUM_CODE[Number];
 352   2          break;
 353   2        }
 354   1      }
 355          //-----------------------------------------------------------------------------
 356          //-----------------------------------------------------------------------------
 357          void Fan_Display(unsigned char Type)
 358          { switch(Type)
 359   1        {case 0x02://故障报警
 360   2            if(FlashDisplayTime >10)//秒闪
 361   2            { LCD_06.DATA &= 0x38;
 362   3            }
 363   2            else
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 7   

 364   2            { LCD_06.DATA |= 0xC7;
 365   3            }
 366   2            Fan_DisplayIndex = 0x00;
 367   2            Fan_DisplayTime = 0x00;
 368   2            break;
 369   2         case 0x01:
 370   2            if(Fan_DisplayTime >Fan_DisplayHold)
 371   2            { Fan_DisplayTime = 0x00;
 372   3              if(Fan_DisplayHold >3)//逐渐加速
 373   3              { Fan_DisplayHold--;    }
 374   3            }
 375   2            else{ break;    }
 376   2            //----------------------------------------
 377   2            LCD_06.DATA |= 0xC7;
 378   2            //----------------------------------------
 379   2            switch(Fan_DisplayIndex++)
 380   2            {case 0x04:
 381   3                LCD_06.BIT.BIT_7 = EQUAL_L;//风扇叶片 4
 382   3              break;
 383   3             case 0x03:
 384   3                LCD_06.BIT.BIT_8 = EQUAL_L;//风扇叶片 3
 385   3              break;
 386   3             case 0x02:
 387   3                LCD_06.BIT.BIT_3 = EQUAL_L;//风扇叶片 2
 388   3              break;
 389   3             case 0x01:
 390   3                LCD_06.BIT.BIT_1 = EQUAL_L;//风扇叶片 1
 391   3              break;
 392   3             default:////初始状态
 393   3                Fan_DisplayIndex = 0x01;
 394   3                Fan_DisplayHold = 40;//设定加速时间100mS
 395   3              break;
 396   3            }
 397   2          break;
 398   2         default:////默认风扇图标全显示 
 399   2            LCD_06.DATA &= 0x38;
 400   2            //----------------------------------------
 401   2            Fan_DisplayIndex = 0x00;
 402   2            Fan_DisplayTime = 0x00;
 403   2            Fan_DisplayHold = 40;
 404   2          break;
 405   2        }
 406   1      }
 407          //-----------------------------------------------------------------------------
 408          
 409          void Gear_Display(char Gear)
 410          {
 411   1        if(Gear < 0 && Gear > 9)
 412   1        { return ;}
 413   1        //----------------------------------------
 414   1        LCD_03.DATA &= ~(0xF0);
 415   1        LCD_04.DATA &= ~(0xAF);
 416   1        //----------------------------------------
 417   1        switch(Gear)
 418   1        {
 419   2          case 0: LCD_04.DATA |= 0x80;  break;
 420   2          case 1: LCD_04.DATA |= 0xA0;  break;
 421   2          case 2: LCD_04.DATA |= 0xA1;  break;
 422   2          case 3: LCD_04.DATA |= 0xA3;  break;
 423   2          case 4: LCD_04.DATA |= 0xA7;  break;
 424   2          case 5: LCD_04.DATA |= 0xAF;  break;
 425   2          case 6: LCD_04.DATA |= 0xAF;
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 8   

 426   2              LCD_03.DATA |= 0x80;  break;  
 427   2          case 7: LCD_04.DATA |= 0xAF;
 428   2              LCD_03.DATA |= 0xC0;  break;  
 429   2          case 8: LCD_04.DATA |= 0xAF;
 430   2              LCD_03.DATA |= 0xE0;  break;
 431   2          case 9:LCD_04.DATA |= 0xAF;
 432   2              LCD_03.DATA |= 0xF0;  break;
 433   2          default:  break;
 434   2        }
 435   1      }
 436          //-----------------------------------------------------------------------------
 437          //-----------------------------------------------------------------------------
 438          void RunStateDisplay(void)//实时显示运行状态
 439          { if(FlashDisplayTime <10)//秒 闪
 440   1        { LCD_03.BIT.BIT_3 = EQUAL_H;     }//电压正常
 441   1        else
 442   1        { if((ErrorIndex == 0x02)||(ErrorIndex == 0x03))
 443   2          { LCD_03.BIT.BIT_3 = EQUAL_L; }//电池 图标
 444   2        }
 445   1          //-------------------------------------------
 446   1        if(ErrorIndex != 0x04)//点火塞故障
 447   1        { if(Ignition_CUR.Current >80)
 448   2          { LCD_05.BIT.BIT_8 = EQUAL_H;   }//点火塞
 449   2          else
 450   2          { LCD_05.BIT.BIT_8 = EQUAL_L;   }
 451   2        }
 452   1        else
 453   1        { if(FlashDisplayTime <10)//秒 闪
 454   2          { LCD_05.BIT.BIT_8 = EQUAL_H;     }
 455   2          else
 456   2          { LCD_05.BIT.BIT_8 = EQUAL_L;   }
 457   2        }
 458   1          //-------------------------------------------
 459   1        if(ErrorIndex != 0x05)
 460   1        { if(OilPumpFrequency != 0x00)
 461   2          { LCD_06.BIT.BIT_5 = EQUAL_H;   }//油泵 图标
 462   2          else
 463   2          { LCD_06.BIT.BIT_5 = EQUAL_L;   }//油泵 图标
 464   2        }
 465   1        else
 466   1        { if(FlashDisplayTime <10)//秒 闪
 467   2          { LCD_06.BIT.BIT_5 = EQUAL_H;   }//油泵 图标
 468   2          else
 469   2          { LCD_06.BIT.BIT_5 = EQUAL_L;   }//油泵 图标
 470   2        }
 471   1          //-------------------------------------------
 472   1        /*
 473   1        if(WaterPump_CUR.Data > 35)//水泵工作电压大于 0.35 A    //未改
 474   1        { LCD_06.BIT.BIT_7 = EQUAL_H;//水泵图标
 475   1        }
 476   1        else
 477   1        { LCD_06.BIT.BIT_7 = EQUAL_L;//水泵图标
 478   1        }
 479   1        */
 480   1          //-------------------------------------------
 481   1        if(FlashDisplayTime <10)//秒 闪
 482   1        { LCD_05.BIT.BIT_7 = EQUAL_H; }//温度传感器
 483   1        else
 484   1        { if((ErrorIndex == 0x06)||(ErrorIndex == 0x0A))
 485   2          { LCD_05.BIT.BIT_7 = EQUAL_L;}//温度传感器
 486   2        }
 487   1          //-------------------------------------------
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 9   

 488   1        if(ErrorIndex == 0x07)//电机故障报警
 489   1        { Fan_Display(2);   }
 490   1        else if((SystemRunState > TASK_IdleMode)&&(SystemRunState < TASK_Shutdown))
 491   1          { Fan_Display(1);   }//风扇叶轮转动
 492   1          else//----------------------OF
 493   1        { Fan_Display(0);   }//风扇叶轮停止
 494   1          //-------------------------------------------
 495   1          //-------------------------------------------
 496   1        if(Config.Struct.RF_Address.DATA != 0x00)//遥控已匹配
 497   1        { LCD_07.DATA |= 0x0F;
 498   2          LCD_08.BIT.BIT_4 = EQUAL_H;//天线 图标  
 499   2        }
 500   1        else
 501   1        { LCD_07.DATA &= 0xF0;
 502   2          LCD_08.BIT.BIT_4 = EQUAL_L;//天线 图标
 503   2        }
 504   1          //------------------------------------------- //补充
 505   1        if(FlashDisplayTime >10)//秒 闪   //未改
 506   1        { LCD_05.BIT.BIT_6 = EQUAL_L;   }
 507   1        else
 508   1        { if(ErrorIndex == 0x08)
 509   2          { LCD_05.BIT.BIT_6 = EQUAL_H;   }//断线 图标
 510   2        }
 511   1        //-----------------------------------
 512   1        if((AlaramTime[0] != 0x00)||(AlaramTime[3] != 0x00))
 513   1        { LCD_05.BIT.BIT_2 = EQUAL_H;   }//定时 闹钟
 514   1        else
 515   1        { LCD_05.BIT.BIT_2 = EQUAL_L;   }
 516   1      //  if(AudioData.AudioSwitch == 0x00)
 517   1      //  { LCD_00.BIT.BIT_1 = EQUAL_L;   }//喇叭 图标 关
 518   1      //  else
 519   1      //  { LCD_00.BIT.BIT_1 = EQUAL_H;   }//喇叭 图标 开
 520   1        //-------------------------------------------
 521   1        if(Config.Struct.TemperatureType != 0x01)//改变控温方式
 522   1        { LCD_05.BIT.BIT_4 = EQUAL_L;//手动
 523   2          LCD_05.BIT.BIT_3 = EQUAL_H;//自动
 524   2        }
 525   1        else//按照档位显示
 526   1        { LCD_05.BIT.BIT_3 = EQUAL_L;//自动
 527   2          LCD_05.BIT.BIT_4 = EQUAL_H;//手动
 528   2        }
 529   1        //-------------------------------------------
 530   1        if(Config.Struct.TemperatureType == 0x01)
 531   1        {
 532   2          Gear_Display(Config.Struct.EnergyLevel);
 533   2        }
 534   1        //-------------------------------------------
 535   1        if(SystemStateHold != SystemRunState)
 536   1        { SystemStateHold = SystemRunState;
 537   2          if((SystemRunState ==TASK_Self_Test)||(SystemRunState ==TASK_Ignition)
 538   2          ||(SystemRunState ==TASK_Turn_Off)||(SystemRunState ==TASK_Wait_Off))
 539   2          { SystemStateTime = 90;
 540   3            DisplayStateIndex = 0x00;//优先显示 开 关机状态
 541   3          }//4.5秒
 542   2        }
 543   1        if(SystemStateTime > 0x00)
 544   1        { if((SystemRunState ==TASK_Self_Test)||(SystemRunState ==TASK_Ignition))
 545   2          { Number_1_Display(0,0);
 546   3            Number_2_Display(0,0);
 547   3            Number_3_Display(2,12);
 548   3            Number_4_Display(2,13);//开机提示 ON
 549   3          #if   (LanguageType == Multilingual)  //多种语言
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 10  

                    WT588F_Play_Index(0x02);//开机
                  #elif (LanguageType == Chinese) //单独中文语音
                    WT588F_Play_Index(1);//提示开机
                  #endif
 554   3          }
 555   2          if((SystemRunState ==TASK_Turn_Off)||(SystemRunState ==TASK_Wait_Off))
 556   2          { Number_1_Display(0,0);
 557   3            Number_2_Display(2,12);
 558   3            Number_3_Display(2,11);
 559   3            Number_4_Display(2,11);//关机提示 OF
 560   3          #if   (LanguageType == Multilingual)  //多种语言
                    WT588F_Play_Index(0x05);//开始关机
                  #elif (LanguageType == Chinese) //单独中文语音
                    WT588F_Play_Index(4);//提示关机
                  #endif
 565   3          }
 566   2          LCD_03.BIT.BIT_2 = EQUAL_L;//时间 秒点
 567   2          LCD_02.BIT.BIT_4 = EQUAL_L;//3 下点
 568   2          LCD_03.BIT.BIT_4 = EQUAL_L;//3 上点
 569   2          LCD_03.BIT.BIT_1 = EQUAL_L;//2 下点
 570   2        }
 571   1      //  else
 572   1      //  { if(SetupTemperatureHold != Config.Struct.SetupTemperature)
 573   1      //    { SetupTemperatureHold = Config.Struct.SetupTemperature;
 574   1      //    #if   (LanguageType == Multilingual)  //多种语言
 575   1      //      if(Config.Struct.TemperatureType == 0xCD)
 576   1      //      { WT588F_Play_Index(((Config.Struct.SetupTemperature -8) /3) +21);  }
 577   1      //      else
 578   1      //      { WT588F_Play_Index(23 + Config.Struct.SetupTemperature);   }
 579   1      //    #endif
 580   1      //    }
 581   1      //    //-----------------------------------
 582   1      //    if(ErrorIndex >0x01)
 583   1      //    { if(ErrorIndexHold != ErrorIndex)
 584   1      //      { ErrorIndexHold = ErrorIndex;
 585   1      //        DisplayStateIndex = 0x00;
 586   1      //        DisplaySetIndex = 0x00;
 587   1      //      }
 588   1      //    #if   (LanguageType == Multilingual)  //多种语言
 589   1      //      WT588F_Play_Index((ErrorIndex -0x01) +5);//故障码播报
 590   1      //    #else
 591   1      //      WT588F_Play_Index((ErrorIndex -0x01) +4);//故障码播报
 592   1      //    #endif
 593   1      //    }//故障码出现时优先显示故障码
 594   1      //  }
 595   1      }
 596          //-----------------------------------------------------------------------------
 597          void  DisplayDataProcess(void)
 598          {signed long int_Temp_1,int_Temp_2,int_Temp_3; signed char Temp_0 , Temp_1;
 599   1        switch(DisplaySetIndex)
 600   1          {case 0x0E://手动开启水泵
 601   2            if((SystemRunState > TASK_Self_Test)&&(SystemRunState < TASK_Shutdown))
 602   2            { DisplayStateIndex = 0x02;   }//退出手动泵油状态
 603   2            //--------------------------------------------------
 604   2            ExitSetupTime = 00;//以秒为单位（禁止自动退出）
 605   2            //--------------------------------------------------
 606   2            switch(DisplayStateIndex)
 607   2            {case 0x02:
 608   3                SystemRunIndex = UART_StopWaterPump;
 609   3                DisplaySetIndex = 0x00;//下一项
 610   3                DisplayStateIndex = 0x00;
 611   3              break;
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 11  

 612   3             case 0x01:
 613   3                Number_1_Display(1,16);
 614   3                Number_2_Display(0,0);
 615   3                if(WaterPump_CUR.Data > 35)
 616   3                { Number_3_Display(2,12);
 617   4                  Number_4_Display(2,13);
 618   4                }
 619   3                else
 620   3                { Number_3_Display(2,12);
 621   4                  Number_4_Display(2,11);
 622   4                }
 623   3                //---------------------------
 624   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 625   3                {   System.BIT.BIT_02 = EQUAL_L;
 626   4                  //-----------------------
 627   4                  SystemRunIndex = UART_RunWaterPump;
 628   4                }
 629   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
 630   3                {   System.BIT.BIT_03 = EQUAL_L;
 631   4                  //-----------------------
 632   4                  SystemRunIndex = UART_StopWaterPump;
 633   4                }
 634   3      //          if(System.BIT.BIT_01 == EQUAL_H)//确认
 635   3      //          {   System.BIT.BIT_01 = EQUAL_L;
 636   3      //            DisplayStateIndex++;//下一项
 637   3      //          }
 638   3              break;
 639   3             default:
 640   3                ClearBitDisplay();
 641   3                //---------------------------
 642   3                DisplayStateIndex = 0x01;
 643   3                SystemRunIndex = 0x00;
 644   3              break;
 645   3            }
 646   2              break;
 647   2           case 0x0D://手动泵油
 648   2            if((SystemRunState > TASK_Self_Test)&&(SystemRunState < TASK_Shutdown))
 649   2            { DisplayStateIndex = 0x02;   }//退出手动泵油状态
 650   2            //--------------------------------------------------
 651   2            ExitSetupTime = 00;//以秒为单位（禁止自动退出）
 652   2            //--------------------------------------------------
 653   2            switch(DisplayStateIndex)
 654   2            {case 0x02:
 655   3                DisplaySetIndex = 0x00;//下一项
 656   3                DisplayStateIndex = 0x00;
 657   3              
 658   3              break;
 659   3             case 0x01:
 660   3                Number_1_Display(1,10);
 661   3                Number_2_Display(0,0);
 662   3                if(OilPumpFrequency != 0x00)
 663   3                { Number_3_Display(2,12);
 664   4                  Number_4_Display(2,13);
 665   4                }
 666   3                else
 667   3                { Number_3_Display(2,12);
 668   4                  Number_4_Display(2,11);
 669   4                }
 670   3                //---------------------------
 671   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 672   3                {   System.BIT.BIT_02 = EQUAL_L;
 673   4                  //-----------------------
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 12  

 674   4                  SystemRunIndex = UART_PumpOil;
 675   4                #if   (LanguageType == Multilingual)  //多种语言
                          WT588F_Play_Index(0x14);//开始手动泵油
                        #elif (LanguageType == Chinese) //单独中文语音
                          WT588F_Play_Index(0x13);//开始手动泵油
                        #endif
 680   4                }
 681   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
 682   3                {   System.BIT.BIT_03 = EQUAL_L;
 683   4                  //-----------------------
 684   4                  SystemRunIndex = UART_ExitPumpOil;
 685   4                #if   (LanguageType == Multilingual)  //多种语言
                          WT588F_Play_Index(0x15);//停止手动泵油
                        #elif (LanguageType == Chinese) //单独中文语音
                          WT588F_Play_Index(0x14);//停止手动泵油
                        #endif
 690   4                }
 691   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
 692   3                {   System.BIT.BIT_01 = EQUAL_L;
 693   4                  DisplayStateIndex++;//下一项
 694   4                  SystemRunIndex = UART_ExitPumpOil;
 695   4                #if   (LanguageType == Multilingual)  //多种语言
                          WT588F_Play_Index(0x15);//停止手动泵油
                        #elif (LanguageType == Chinese) //单独中文语音
                          WT588F_Play_Index(0x14);//停止手动泵油
                        #endif
 700   4                }
 701   3              break;
 702   3             default:
 703   3                ClearBitDisplay();
 704   3                //--------------------------------
 705   3                DisplayStateIndex = 0x01;
 706   3              break;
 707   3            }
 708   2              break;
 709   2           case 0x0C://遥控地址码设置
 710   2            switch(DisplayStateIndex)
 711   2            {case 0x01:
 712   3      
 713   3                Number_1_Display(2,10);
 714   3                Number_2_Display(2,11);//闪烁
 715   3                Number_3_Display(2,20);//闪烁   
 716   3                Number_4_Display(2,19);//闪烁   
 717   3      
 718   3              //---------------------------------------------------------
 719   3      //          Number_1_Display(2,10);
 720   3      //          Number_2_Display(2,11);//闪烁
 721   3      //          Number_3_Display(2,19);//闪烁   
 722   3      //          if(Config.Struct.RF_ModeSelect == Select_OneWay_RF)//单向
 723   3      //          { Number_4_Display(2,1);    }
 724   3      //          else
 725   3      //          { Number_4_Display(2,2);    }
 726   3      //          //---------------------------
 727   3      //          if(System.BIT.BIT_02 == EQUAL_H)//上调
 728   3      //          {   System.BIT.BIT_02 = EQUAL_L;
 729   3      //            //-----------------------
 730   3      //            Config.Struct.RF_ModeSelect = Select_TwoWay_RF;
 731   3      //            CMT2300_SetInitial();//重新配置 无线芯片
 732   3      //            CMT2300_PairingTime = CMT2300_ADDRLEARNTIME;
 733   3      //            RF_LearnAddrssTime = 0;
 734   3      //          }
 735   3      //          if(System.BIT.BIT_03 == EQUAL_H)//下调
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 13  

 736   3      //          {   System.BIT.BIT_03 = EQUAL_L;
 737   3      //            //-----------------------
 738   3      //            Config.Struct.RF_ModeSelect = Select_OneWay_RF;
 739   3      //            CMT2300_SetInitial();//重新配置 无线芯片
 740   3      //            RF_LearnAddrssTime = RF_ADDRLEARNTIME; 
 741   3      //            CMT2300_PairingTime = 0;
 742   3      //          }
 743   3                //---------------------------
 744   3                if((RF_LearnAddrssTime == 0x00)&&(CMT2300_PairingTime == 0x00))//完成学习后退出
 745   3                { DisplaySetIndex = 0x00;
 746   4                            DisplayStateIndex = 0x00;
 747   4      
 748   4                  RF_LearnAddrssTime = 0x00;
 749   4                  CMT2300_PairingTime = 0x00;
 750   4                }
 751   3              break;
 752   3             default:
 753   3                ClearBitDisplay();
 754   3                //--------------------------------
 755   3                DisplayStateIndex = 0x01;
 756   3                //--------------------------------
 757   3                Config.Struct.RF_ModeSelect = Select_OneWay_RF;   //固定为单向
 758   3                //--------------------------------
 759   3                if(Config.Struct.RF_ModeSelect == Select_OneWay_RF)//单向
 760   3                { RF_LearnAddrssTime = RF_ADDRLEARNTIME;
 761   4                  CMT2300_PairingTime = 0x00;
 762   4                }//配对等待时间
 763   3                else
 764   3                { CMT2300_PairingTime = CMT2300_ADDRLEARNTIME;
 765   4                  RF_LearnAddrssTime = 0x00;
 766   4                }
 767   3                //--------------------------------
 768   3                CMT2300_SetInitial();//重新配置 无线芯片
 769   3                //--------------------------------
 770   3              #if   (LanguageType == Multilingual)  //多种语言
                        WT588F_Play_Index(0x10);//遥控配对
                      #elif (LanguageType == Chinese) //单独中文语音
                        WT588F_Play_Index(15);//遥控配对
                      #endif
 775   3              break;
 776   3            }
 777   2              break;
 778   2      ///////////////////////////////////////////////////////////////////////////////////////////////////
 779   2           case 0x0A://参数存储
 780   2            RunDataUpdate();//存储设置参数
 781   2         case 0x09://更新参数
 782   2            RunData_Initial();//取得设置参数
 783   2            ClearBitDisplay();//清除各种状态显示标志  //补充
 784   2        //----------------------------------------------------------
 785   2            System.BIT.BIT_04 = EQUAL_L;//清除 密码更新状态
 786   2            DisplaySetIndex = 0x00;//退出
 787   2            DisplayStateIndex = 0x00;
 788   2          break;
 789   2           case 0x08://电压，点火功率，工作模式(单次加热-循环加热)，密码
 790   2            switch(DisplayStateIndex)
 791   2            {case 0x05://修改密码
 792   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 793   3                {   System.BIT.BIT_02 = EQUAL_L;
 794   4                }
 795   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
 796   3                {   System.BIT.BIT_03 = EQUAL_L;
 797   4                  //-----------------------
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 14  

 798   4                  DisplayStateIndex = 0x04;
 799   4                }
 800   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
 801   3                {   System.BIT.BIT_01 = EQUAL_L;
 802   4                  DisplaySetIndex = 0x03;//进入密码修改状态
 803   4                  System.BIT.BIT_01 = EQUAL_L;
 804   4                  System.BIT.BIT_02 = EQUAL_L;
 805   4                  System.BIT.BIT_03 = EQUAL_L;
 806   4                  System.BIT.BIT_04 = EQUAL_H;
 807   4                  DisplayStateIndex = 0x40;//可更改密码
 808   4                }
 809   3                Number_1_Display(0,0);
 810   3                Number_2_Display(0,0);
 811   3                Number_3_Display(1,12);
 812   3                Number_4_Display(1,13);
 813   3              break;
 814   3             case 0x04:
 815   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 816   3                {   System.BIT.BIT_02 = EQUAL_L;
 817   4                  //-----------------------
 818   4                  DisplayStateIndex = 0x05;
 819   4                }
 820   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
 821   3                {   System.BIT.BIT_03 = EQUAL_L;
 822   4                }
 823   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
 824   3                {   System.BIT.BIT_01 = EQUAL_L;
 825   4                  DisplaySetIndex = 0x0A;//更新参数退出
 826   4                }
 827   3                Number_1_Display(0,0);
 828   3                Number_2_Display(0,0);
 829   3                Number_3_Display(1,12);
 830   3                Number_4_Display(1,11);
 831   3              break;
 832   3             case 0x03://工作模式(单次加热-循环加热)
 833   3                Number_1_Display(1,18);
 834   3                Number_2_Display(1,17);
 835   3                Number_3_Display(1,19);
 836   3                Number_4_Display(2,Config.Struct.RunStateType %10);
 837   3                //---------------------------
 838   3                LCD_00.BIT.BIT_7 = EQUAL_L;//电压 图标
 839   3                //---------------------------
 840   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 841   3                {   System.BIT.BIT_02 = EQUAL_L;
 842   4                  //-----------------------
 843   4                  if(Config.Struct.RunStateType  <2)
 844   4                  { Config.Struct.RunStateType ++;    }
 845   4                }
 846   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
 847   3                {   System.BIT.BIT_03 = EQUAL_L;
 848   4                  //-----------------------
 849   4                  if(Config.Struct.RunStateType  >1)
 850   4                  { Config.Struct.RunStateType --;    }
 851   4                }
 852   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
 853   3                {   System.BIT.BIT_01 = EQUAL_L;
 854   4                  DisplayStateIndex++;//下一项
 855   4                }
 856   3              break;
 857   3             case 0x02://点火塞功率选择
 858   3                Number_1_Display(1,16);
 859   3                Number_2_Display(1,11);
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 15  

 860   3                Number_3_Display(1,19);
 861   3                Number_4_Display(2,Config.Struct.Ignition_Power %10);
 862   3                //---------------------------
 863   3                LCD_00.BIT.BIT_7 = EQUAL_L;//电压 图标
 864   3                //---------------------------
 865   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 866   3                {   System.BIT.BIT_02 = EQUAL_L;
 867   4                  //-----------------------
 868   4                  if(Config.Struct.Ignition_Power  <6)
 869   4                  { Config.Struct.Ignition_Power ++;    }
 870   4                }
 871   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
 872   3                {   System.BIT.BIT_03 = EQUAL_L;
 873   4                  //-----------------------
 874   4                  if(Config.Struct.Ignition_Power  >1)
 875   4                  { Config.Struct.Ignition_Power --;    }
 876   4                }
 877   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
 878   3                {   System.BIT.BIT_01 = EQUAL_L;
 879   4                  DisplayStateIndex++;//下一项
 880   4                }
 881   3              break;
 882   3             case 0x01://工作电压
 883   3                Number_1_Display(1,17);
 884   3                Number_2_Display(1,19);
 885   3                Number_3_Display(2,(Config.Struct.SystemPowerVolatge/10) /10);
 886   3                Number_4_Display(2,(Config.Struct.SystemPowerVolatge/10) %10);
 887   3                //---------------------------
 888   3                LCD_00.BIT.BIT_7 = EQUAL_H;//电压 图标
 889   3                //---------------------------
 890   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 891   3                {   System.BIT.BIT_02 = EQUAL_L;
 892   4                  //-----------------------
 893   4                  Config.Struct.SystemPowerVolatge = 240;
 894   4                }
 895   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
 896   3                {   System.BIT.BIT_03 = EQUAL_L;
 897   4                  //-----------------------
 898   4                  Config.Struct.SystemPowerVolatge = 120;
 899   4                }
 900   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
 901   3                {   System.BIT.BIT_01 = EQUAL_L;
 902   4                  DisplayStateIndex++;//下一项
 903   4                }
 904   3              break;
 905   3             default:
 906   3                ClearBitDisplay();
 907   3                LCD_00.BIT.BIT_6 = EQUAL_L;//转速 图标
 908   3                LCD_06.BIT.BIT_4 = EQUAL_H;//设置 图标
 909   3                DisplayStateIndex = 0x01;
 910   3              break;
 911   3            }
 912   2            break;
 913   2         case 0x07://终止转速设定
 914   2            Set_Speed.Array[0] = Config.Struct.MAX_FanSpeed.Array[0];
 915   2            Set_Speed.Array[1] = Config.Struct.MAX_FanSpeed.Array[1];
 916   2            switch(DisplayStateIndex)
 917   2            {case 0x04:
 918   3                DisplaySetIndex++;//下一项
 919   3                DisplayStateIndex = 0x00;
 920   3              break;
 921   3             case 0x03:
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 16  

 922   3                int_Temp_1 = Set_Speed.Data /100;//分解
 923   3                int_Temp_3 = Set_Speed.Data %10;
 924   3                //---------------------------
 925   3                Number_1_Display(1,Set_Speed.Data /1000);
 926   3                Set_Speed.Data %= 1000;
 927   3                Number_2_Display(1,Set_Speed.Data /100);
 928   3                Set_Speed.Data %= 100;
 929   3                Number_3_Display(2,Set_Speed.Data /10);
 930   3                int_Temp_2 = Set_Speed.Data /10;//权值
 931   3                Number_4_Display(1,Set_Speed.Data %10);
 932   3                //---------------------------
 933   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 934   3                {   System.BIT.BIT_02 = EQUAL_L;
 935   4                  //-----------------------
 936   4                  if(++int_Temp_2 > 9)
 937   4                  { int_Temp_2 = 0;   }
 938   4                }
 939   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
 940   3                {   System.BIT.BIT_03 = EQUAL_L;
 941   4                  //-----------------------
 942   4                  if(int_Temp_2 >0)
 943   4                  { int_Temp_2--;   }
 944   4                  else
 945   4                  { int_Temp_2 = 9;   }
 946   4                }
 947   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
 948   3                {   System.BIT.BIT_01 = EQUAL_L;
 949   4                  DisplayStateIndex++;//下一项
 950   4                }
 951   3                //---------------------------
 952   3                Set_Speed.Data = (int_Temp_1 *100)+(int_Temp_2 *10)+int_Temp_3;//合成
 953   3              break;
 954   3             case 0x02:
 955   3                int_Temp_1 = Set_Speed.Data /1000;//分解
 956   3                int_Temp_3 = Set_Speed.Data %100;
 957   3                //---------------------------
 958   3                Number_1_Display(1,Set_Speed.Data /1000);
 959   3                Set_Speed.Data %= 1000;
 960   3                int_Temp_2 = Set_Speed.Data /100;//权值
 961   3                Number_2_Display(2,Set_Speed.Data /100);
 962   3                Set_Speed.Data %= 100;
 963   3                Number_3_Display(1,Set_Speed.Data /10);
 964   3                Number_4_Display(1,Set_Speed.Data %10);
 965   3                //---------------------------
 966   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 967   3                {   System.BIT.BIT_02 = EQUAL_L;
 968   4                  //-----------------------
 969   4                  if(++int_Temp_2 > 9)
 970   4                  { int_Temp_2 = 0;   }
 971   4                }
 972   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
 973   3                {   System.BIT.BIT_03 = EQUAL_L;
 974   4                  //-----------------------
 975   4                  if(int_Temp_2 >0)
 976   4                  { int_Temp_2--;   }
 977   4                  else
 978   4                  { int_Temp_2 = 9;   }
 979   4                }
 980   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
 981   3                {   System.BIT.BIT_01 = EQUAL_L;
 982   4                  DisplayStateIndex++;//下一项
 983   4                }
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 17  

 984   3                //---------------------------
 985   3                Set_Speed.Data = (int_Temp_1 *1000)+(int_Temp_2 *100)+int_Temp_3;//合成
 986   3              break;
 987   3             case 0x01:
 988   3                int_Temp_1 = Set_Speed.Data /1000;//分解
 989   3                int_Temp_2 = Set_Speed.Data %1000;
 990   3                //---------------------------
 991   3                Number_1_Display(2,Set_Speed.Data /1000);
 992   3                Set_Speed.Data %= 1000;
 993   3                Number_2_Display(1,Set_Speed.Data /100);
 994   3                Set_Speed.Data %= 100;
 995   3                Number_3_Display(1,Set_Speed.Data /10);
 996   3                Number_4_Display(1,Set_Speed.Data %10);
 997   3                //---------------------------
 998   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
 999   3                {   System.BIT.BIT_02 = EQUAL_L;
1000   4                  //-----------------------
1001   4                  if(++int_Temp_1 > 9)
1002   4                  { int_Temp_1 = 6;   }
1003   4                }
1004   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1005   3                {   System.BIT.BIT_03 = EQUAL_L;
1006   4                  //-----------------------
1007   4                  if(--int_Temp_1 < 1)
1008   4                  { int_Temp_1 = 9;   }
1009   4                }
1010   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1011   3                {   System.BIT.BIT_01 = EQUAL_L;
1012   4                  DisplayStateIndex++;//下一项
1013   4                }
1014   3                //---------------------------
1015   3                Set_Speed.Data = (int_Temp_1 *1000) +int_Temp_2;//合成
1016   3              break;
1017   3             default:
1018   3                ClearBitDisplay();
1019   3                LCD_00.BIT.BIT_6 = EQUAL_H;//转速 图标
1020   3                LCD_06.BIT.BIT_4 = EQUAL_H;//设置 图标
1021   3                DisplayStateIndex = 0x01;
1022   3              break;
1023   3            }
1024   2            if(Set_Speed.Data < (Config.Struct.MIN_FanSpeed.DATA +200)){  Set_Speed.Data = (Config.Struct.MIN_FanSpe
             -ed.DATA +200);  }
1025   2            if(Set_Speed.Data > 9900){  Set_Speed.Data = 9900;  }//限制
1026   2            Config.Struct.MAX_FanSpeed.DATA = Set_Speed.Data;
1027   2            break;
1028   2         case 0x06://起始转速设定
1029   2            Set_Speed.Array[0] = Config.Struct.MIN_FanSpeed.Array[0];
1030   2            Set_Speed.Array[1] = Config.Struct.MIN_FanSpeed.Array[1];
1031   2            switch(DisplayStateIndex)
1032   2            {case 0x04:
1033   3                DisplaySetIndex++;//下一项
1034   3                DisplayStateIndex = 0x00;
1035   3              break;
1036   3             case 0x03:
1037   3                int_Temp_1 = Set_Speed.Data /100;//分解
1038   3                int_Temp_3 = Set_Speed.Data %10;
1039   3                //---------------------------
1040   3                Number_1_Display(1,Set_Speed.Data /1000);
1041   3                Set_Speed.Data %= 1000;
1042   3                Number_2_Display(1,Set_Speed.Data /100);
1043   3                Set_Speed.Data %= 100;
1044   3                Number_3_Display(2,Set_Speed.Data /10);
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 18  

1045   3                int_Temp_2 = Set_Speed.Data /10;//权值
1046   3                Number_4_Display(1,Set_Speed.Data %10);
1047   3                //---------------------------
1048   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1049   3                {   System.BIT.BIT_02 = EQUAL_L;
1050   4                  //-----------------------
1051   4                  if(++int_Temp_2 > 9)
1052   4                  { int_Temp_2 = 0;   }
1053   4                }
1054   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1055   3                {   System.BIT.BIT_03 = EQUAL_L;
1056   4                  //-----------------------
1057   4                  if(int_Temp_2 >0)
1058   4                  { int_Temp_2--;   }
1059   4                  else
1060   4                  { int_Temp_2 = 9;   }
1061   4                }
1062   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1063   3                {   System.BIT.BIT_01 = EQUAL_L;
1064   4                  DisplayStateIndex++;//下一项
1065   4                }
1066   3                //---------------------------
1067   3                Set_Speed.Data = (int_Temp_1 *100)+(int_Temp_2 *10)+int_Temp_3;//合成
1068   3              break;
1069   3             case 0x02:
1070   3                int_Temp_1 = Set_Speed.Data /1000;//分解
1071   3                int_Temp_3 = Set_Speed.Data %100;
1072   3                //---------------------------
1073   3                Number_1_Display(1,Set_Speed.Data /1000);
1074   3                Set_Speed.Data %= 1000;
1075   3                int_Temp_2 = Set_Speed.Data /100;//权值
1076   3                Number_2_Display(2,Set_Speed.Data /100);
1077   3                Set_Speed.Data %= 100;
1078   3                Number_3_Display(1,Set_Speed.Data /10);
1079   3                Number_4_Display(1,Set_Speed.Data %10);
1080   3                //---------------------------
1081   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1082   3                {   System.BIT.BIT_02 = EQUAL_L;
1083   4                  //-----------------------
1084   4                  if(++int_Temp_2 > 9)
1085   4                  { int_Temp_2 = 0;   }
1086   4                }
1087   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1088   3                {   System.BIT.BIT_03 = EQUAL_L;
1089   4                  //-----------------------
1090   4                  if(int_Temp_2 >0)
1091   4                  { int_Temp_2--;   }
1092   4                  else
1093   4                  { int_Temp_2 = 9;   }
1094   4                }
1095   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1096   3                {   System.BIT.BIT_01 = EQUAL_L;
1097   4                  DisplayStateIndex++;//下一项
1098   4                }
1099   3                //---------------------------
1100   3                Set_Speed.Data = (int_Temp_1 *1000)+(int_Temp_2 *100)+int_Temp_3;//合成
1101   3              break;
1102   3             case 0x01:
1103   3                int_Temp_1 = Set_Speed.Data /1000;//分解
1104   3                int_Temp_2 = Set_Speed.Data %1000;
1105   3                //---------------------------
1106   3                Number_1_Display(2,Set_Speed.Data /1000);
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 19  

1107   3                Set_Speed.Data %= 1000;
1108   3                Number_2_Display(1,Set_Speed.Data /100);
1109   3                Set_Speed.Data %= 100;
1110   3                Number_3_Display(1,Set_Speed.Data /10);
1111   3                Number_4_Display(1,Set_Speed.Data %10);
1112   3                //---------------------------
1113   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1114   3                {   System.BIT.BIT_02 = EQUAL_L;
1115   4                  //-----------------------
1116   4                  if(++int_Temp_1 > 6)
1117   4                  { int_Temp_1 = 1;   }
1118   4                }
1119   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1120   3                {   System.BIT.BIT_03 = EQUAL_L;
1121   4                  //-----------------------
1122   4                  if(int_Temp_1 >1)
1123   4                  { int_Temp_1--;   }
1124   4                  else
1125   4                  { int_Temp_1 = 6;   }
1126   4                }
1127   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1128   3                {   System.BIT.BIT_01 = EQUAL_L;
1129   4                  DisplayStateIndex++;//下一项
1130   4                }
1131   3                //---------------------------
1132   3                Set_Speed.Data = (int_Temp_1 *1000) +int_Temp_2;//合成
1133   3              break;
1134   3             default:
1135   3                ClearBitDisplay();
1136   3                //---------------------------
1137   3                LCD_00.BIT.BIT_6 = EQUAL_H;//转速 图标
1138   3                LCD_06.BIT.BIT_4 = EQUAL_H;//设置 图标
1139   3                DisplayStateIndex = 0x01;
1140   3              break;
1141   3            }
1142   2            if(Set_Speed.Data < 1300){  Set_Speed.Data = 1300;  }
1143   2            if(Set_Speed.Data > 6000){  Set_Speed.Data = 6000;  }//限制
1144   2            Config.Struct.MIN_FanSpeed.DATA = Set_Speed.Data;
1145   2            break;
1146   2         case 0x05://油泵频率
1147   2            switch(DisplayStateIndex)
1148   2            {case 0x02://油泵终止频率
1149   3                Number_1_Display(1,16);
1150   3                Number_2_Display(1,19);
1151   3                Number_3_Display(2,Config.Struct.MAX_OilPumpCycle /10);
1152   3                Number_4_Display(2,Config.Struct.MAX_OilPumpCycle %10);
1153   3                //---------------------------
1154   3                if(FlashDisplayTime <10)
1155   3                { LCD_02.BIT.BIT_4 = EQUAL_H;   }//3 下点
1156   3                else
1157   3                { LCD_02.BIT.BIT_4 = EQUAL_L;   }//3 下点
1158   3                //---------------------------
1159   3                LCD_01.BIT.BIT_4 = EQUAL_H;//频率 图标
1160   3                //---------------------------
1161   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1162   3                {   System.BIT.BIT_02 = EQUAL_L;
1163   4                  //-----------------------
1164   4                  if(Config.Struct.MAX_OilPumpCycle <99)
1165   4                  { Config.Struct.MAX_OilPumpCycle++;   }
1166   4                }
1167   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1168   3                {   System.BIT.BIT_03 = EQUAL_L;
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 20  

1169   4                  //-----------------------
1170   4                  Config.Struct.MAX_OilPumpCycle--;
1171   4                }
1172   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1173   3                {   System.BIT.BIT_01 = EQUAL_L;
1174   4                  DisplaySetIndex++;//下一项
1175   4                  DisplayStateIndex = 0x00;
1176   4                }
1177   3                if(Config.Struct.MAX_OilPumpCycle <(Config.Struct.MIN_OilPumpCycle +10))//限制下限值
1178   3                { Config.Struct.MAX_OilPumpCycle = (Config.Struct.MIN_OilPumpCycle +10);    }
1179   3              break;
1180   3             case 0x01://油泵起始频率
1181   3                Number_1_Display(1,16);
1182   3                Number_2_Display(1,19);
1183   3                Number_3_Display(2,Config.Struct.MIN_OilPumpCycle /10);
1184   3                Number_4_Display(2,Config.Struct.MIN_OilPumpCycle %10);
1185   3                if(FlashDisplayTime <10)  //秒 冒号
1186   3                { LCD_02.BIT.BIT_4 = EQUAL_H;   }//3 下点
1187   3                else
1188   3                { LCD_02.BIT.BIT_4 = EQUAL_L;   }//3 下点
1189   3                //---------------------------
1190   3                LCD_01.BIT.BIT_4 = EQUAL_H;//频率 图标
1191   3                //---------------------------
1192   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1193   3                {   System.BIT.BIT_02 = EQUAL_L;
1194   4                  //-----------------------
1195   4                  if(Config.Struct.MIN_OilPumpCycle <65)
1196   4                  { Config.Struct.MIN_OilPumpCycle++;   }
1197   4                }
1198   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1199   3                {   System.BIT.BIT_03 = EQUAL_L;
1200   4                  //-----------------------
1201   4                  if(Config.Struct.MIN_OilPumpCycle >8)
1202   4                  { Config.Struct.MIN_OilPumpCycle--;   }
1203   4                }
1204   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1205   3                {   System.BIT.BIT_01 = EQUAL_L;
1206   4                  DisplayStateIndex++;//下一项
1207   4                }
1208   3              break;
1209   3             default:
1210   3                ClearBitDisplay();
1211   3                LCD_06.BIT.BIT_4 = EQUAL_H;//设置 图标
1212   3                DisplayStateIndex = 0x01;
1213   3              break;
1214   3            }
1215   2            break;
1216   2         case 0x04://燃油类型，温度下限，温度上限
1217   2            switch(DisplayStateIndex)
1218   2            {case 0x05://温度上限，个位
1219   3                Temp_0 = Config.Struct.SetupTemper_H_Limit /10;
1220   3                Temp_1 = Config.Struct.SetupTemper_H_Limit %10;
1221   3                //--------------------------------------
1222   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1223   3                {   System.BIT.BIT_02 = EQUAL_L;
1224   4                  //-----------------------
1225   4                  if(++Temp_1 >9){  Temp_1 = 0;   }
1226   4                }
1227   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1228   3                {   System.BIT.BIT_03 = EQUAL_L;
1229   4                  //-----------------------
1230   4                  if(--Temp_1 <0){  Temp_1 = 9;   }
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 21  

1231   4                }
1232   3                Config.Struct.SetupTemper_H_Limit = (Temp_0 *10) + Temp_1;
1233   3                if(Config.Struct.SetupTemper_H_Limit <(Config.Struct.SetupTemper_L_Limit +5))
1234   3                { Config.Struct.SetupTemper_H_Limit = (Config.Struct.SetupTemper_L_Limit +5); }
1235   3                //--------------------------------------
1236   3                Number_1_Display(1,10);
1237   3                Number_2_Display(1,19);
1238   3                Number_3_Display(1,Config.Struct.SetupTemper_H_Limit /10);
1239   3                Number_4_Display(2,Config.Struct.SetupTemper_H_Limit %10);//显示时间
1240   3                //--------------------------------------
1241   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1242   3                {   System.BIT.BIT_01 = EQUAL_L;
1243   4                  DisplaySetIndex++;//下一项
1244   4                  DisplayStateIndex = 0x00;
1245   4                }
1246   3              break;
1247   3             case 0x04://温度上限，十位 >= 50度
1248   3                Temp_0 = Config.Struct.SetupTemper_H_Limit /10;
1249   3                Temp_1 = Config.Struct.SetupTemper_H_Limit %10;
1250   3                //--------------------------------------
1251   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1252   3                {   System.BIT.BIT_02 = EQUAL_L;
1253   4                  //-----------------------
1254   4                  if(++Temp_0 > 9){   Temp_0 = 5; }
1255   4                }
1256   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1257   3                {   System.BIT.BIT_03 = EQUAL_L;
1258   4                  //-----------------------
1259   4                  if(--Temp_0 < 5){   Temp_0 = 9; }
1260   4                }
1261   3                Config.Struct.SetupTemper_H_Limit = (Temp_0 *10) + Temp_1;
1262   3                if(Config.Struct.SetupTemper_H_Limit <(Config.Struct.SetupTemper_L_Limit +5))
1263   3                { Config.Struct.SetupTemper_H_Limit = (Config.Struct.SetupTemper_L_Limit +5); }
1264   3                //--------------------------------------
1265   3                Number_1_Display(1,10);
1266   3                Number_2_Display(1,19);
1267   3                Number_3_Display(2,Config.Struct.SetupTemper_H_Limit /10);
1268   3                Number_4_Display(1,Config.Struct.SetupTemper_H_Limit %10);//显示时间
1269   3                //--------------------------------------
1270   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1271   3                {   System.BIT.BIT_01 = EQUAL_L;
1272   4                  DisplayStateIndex++;//下一项
1273   4                }
1274   3              break;
1275   3             case 0x03://温度下限，个位
1276   3                Temp_0 = Config.Struct.SetupTemper_L_Limit /10;
1277   3                Temp_1 = Config.Struct.SetupTemper_L_Limit %10;
1278   3                //--------------------------------------
1279   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1280   3                {   System.BIT.BIT_02 = EQUAL_L;
1281   4                  //-----------------------
1282   4                  if(++Temp_1 >9){  Temp_1 = 0;   }
1283   4                }
1284   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1285   3                {   System.BIT.BIT_03 = EQUAL_L;
1286   4                  //-----------------------
1287   4                  if(--Temp_1 <0){  Temp_1 = 9;   }
1288   4                }
1289   3                Config.Struct.SetupTemper_L_Limit = (Temp_0 *10) + Temp_1;
1290   3                //--------------------------------------
1291   3                Number_1_Display(1,21);
1292   3                Number_2_Display(1,19);
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 22  

1293   3                Number_3_Display(1,Config.Struct.SetupTemper_L_Limit /10);
1294   3                Number_4_Display(2,Config.Struct.SetupTemper_L_Limit %10);//显示时间
1295   3                //--------------------------------------
1296   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1297   3                {   System.BIT.BIT_01 = EQUAL_L;
1298   4                  DisplayStateIndex++;//下一项
1299   4                }
1300   3              break;
1301   3             case 0x02://温度下限，十位 < 80度
1302   3                Temp_0 = Config.Struct.SetupTemper_L_Limit /10;
1303   3                Temp_1 = Config.Struct.SetupTemper_L_Limit %10;
1304   3                //--------------------------------------
1305   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1306   3                {   System.BIT.BIT_02 = EQUAL_L;
1307   4                  //-----------------------
1308   4                  if(++Temp_0 > 7){   Temp_0 = 0; }
1309   4                }
1310   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1311   3                {   System.BIT.BIT_03 = EQUAL_L;
1312   4                  //-----------------------
1313   4                  if(--Temp_0 < 0){   Temp_0 = 7; }
1314   4                }
1315   3                Config.Struct.SetupTemper_L_Limit = (Temp_0 *10) + Temp_1;
1316   3                //--------------------------------------
1317   3                Number_1_Display(1,21);
1318   3                Number_2_Display(1,19);
1319   3                Number_3_Display(2,Config.Struct.SetupTemper_L_Limit /10);
1320   3                Number_4_Display(1,Config.Struct.SetupTemper_L_Limit %10);//显示时间
1321   3                //--------------------------------------
1322   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1323   3                {   System.BIT.BIT_01 = EQUAL_L;
1324   4                  DisplayStateIndex++;//下一项
1325   4                }
1326   3              break;
1327   3             case 0x01://油品类型
1328   3                Number_1_Display(1,11);//F
1329   3                Number_2_Display(1,17);//U
1330   3                Number_3_Display(1,19);
1331   3                Number_4_Display(2,Config.Struct.SetupFuelType  %10);
1332   3                //---------------------------
1333   3                LCD_06.BIT.BIT_5 = EQUAL_L;//电压 图标
1334   3                //---------------------------
1335   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1336   3                {   System.BIT.BIT_02 = EQUAL_L;
1337   4                  //-----------------------
1338   4                  Config.Struct.SetupFuelType = 2;
1339   4                  Config.Struct.MIN_OilPumpCycle = 25;//最小泵油量
1340   4                  Config.Struct.MAX_OilPumpCycle = 66;//最大泵油量
1341   4                  Config.Struct.MIN_FanSpeed.DATA = 2300;//最小风速
1342   4                  Config.Struct.MAX_FanSpeed.DATA = 8650;//最大风速
1343   4                }
1344   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1345   3                {   System.BIT.BIT_03 = EQUAL_L;
1346   4                  //-----------------------
1347   4                  Config.Struct.SetupFuelType = 1;
1348   4                  Config.Struct.MIN_OilPumpCycle = 18;//最小泵油量
1349   4                  Config.Struct.MAX_OilPumpCycle = 58;//最大泵油量
1350   4                  Config.Struct.MIN_FanSpeed.DATA = 3000;//最小风速
1351   4                  Config.Struct.MAX_FanSpeed.DATA = 8650;//最大风速
1352   4                }
1353   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1354   3                {   System.BIT.BIT_01 = EQUAL_L;
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 23  

1355   4                  DisplayStateIndex++;//下一项
1356   4                }
1357   3              break;
1358   3             default:
1359   3                ClearBitDisplay();
1360   3                LCD_06.BIT.BIT_4 = EQUAL_H;//设置 图标
1361   3                DisplayStateIndex = 0x01;
1362   3                //---------------------------
1363   3                if(Config.Struct.SetupFuelType == 0x01)//燃油类型 1柴油，2汽油，3甲醛
1364   3                { Config.Struct.MIN_OilPumpCycle = 18;//最小泵油量
1365   4                  Config.Struct.MAX_OilPumpCycle = 58;//最大泵油量
1366   4                  Config.Struct.MIN_FanSpeed.DATA = 3000;//最小风速
1367   4                  Config.Struct.MAX_FanSpeed.DATA = 8650;//最大风速
1368   4                }
1369   3                else
1370   3                { Config.Struct.MIN_OilPumpCycle = 25;//最小泵油量
1371   4                  Config.Struct.MAX_OilPumpCycle = 66;//最大泵油量
1372   4                  Config.Struct.MIN_FanSpeed.DATA = 2300;//最小风速
1373   4                  Config.Struct.MAX_FanSpeed.DATA = 8650;//最大风速
1374   4                }
1375   3              break;
1376   3            }
1377   2            break;
1378   2         case 0x03://密码管理-合格转入参数设定
1379   2            switch(DisplayStateIndex)
1380   2            {case 0x04:
1381   3                Number_1_Display(1,19);
1382   3                Number_2_Display(1,19);
1383   3                Number_3_Display(1,19);
1384   3                if(System.BIT.BIT_08 == EQUAL_L)
1385   3                { Number_4_Display(2,InputPassword &0x000F);  }
1386   3                else
1387   3                { Number_4_Display(2,19);   }
1388   3                //---------------------------
1389   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1390   3                {   System.BIT.BIT_02 = EQUAL_L;
1391   4                  System.BIT.BIT_08 = EQUAL_L;
1392   4                  //-----------------------
1393   4                  if((InputPassword &0x000F) < 0x0009)
1394   4                  { InputPassword += 0x0001;  }
1395   4                  else
1396   4                  { InputPassword &= 0xFFF0;  }
1397   4                }
1398   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1399   3                {   System.BIT.BIT_03 = EQUAL_L;
1400   4                  System.BIT.BIT_08 = EQUAL_L;
1401   4                  //-----------------------
1402   4                  if((InputPassword &0x000F) > 0x0000)
1403   4                  { InputPassword -= 0x0001;    }
1404   4                  else
1405   4                  { InputPassword &= 0xFFF0;
1406   5                    InputPassword |= 0x0009;
1407   5                  }
1408   4                }
1409   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1410   3                {   System.BIT.BIT_01 = EQUAL_L;
1411   4                  if(System.BIT.BIT_04 == EQUAL_L)
1412   4                  { if((Config.Struct.Password.DATA == InputPassword)
1413   5                     ||(MainPassword == InputPassword))//超级密码
1414   5                    { DisplaySetIndex++;  //下一项
1415   6                      DisplayStateIndex = 0x00;
1416   6                    }
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 24  

1417   5                    else
1418   5                    { DisplayStateIndex = 0x00; }//密码错误重来
1419   5                  }
1420   4                  else//更新管理密码
1421   4                  { Config.Struct.Password.DATA  = InputPassword;
1422   5                    RunDataUpdate();//存储设置参数
1423   5                    DisplaySetIndex = 0x0A;//更新参数退出
1424   5                  }
1425   4                }
1426   3              break;
1427   3             case 0x03:
1428   3                Number_1_Display(1,19);
1429   3                Number_2_Display(1,19);
1430   3                if(System.BIT.BIT_07 == EQUAL_L)
1431   3                { Number_3_Display(2,(InputPassword >>4) &0x000F);    }
1432   3                else
1433   3                { Number_3_Display(2,19);   }
1434   3                Number_4_Display(2,19);
1435   3                //---------------------------
1436   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1437   3                {   System.BIT.BIT_02 = EQUAL_L;
1438   4                  System.BIT.BIT_07 = EQUAL_L;
1439   4                  //-----------------------
1440   4                  if((InputPassword &0x00F0) < 0x0090)
1441   4                  { InputPassword += 0x0010;    }
1442   4                  else
1443   4                  { InputPassword &= 0xFF0F;    }
1444   4                }
1445   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1446   3                {   System.BIT.BIT_03 = EQUAL_L;
1447   4                  System.BIT.BIT_07 = EQUAL_L;
1448   4                  //-----------------------
1449   4                  if((InputPassword &0x00F0) > 0x0000)
1450   4                  { InputPassword -= 0x0010;    }
1451   4                  else
1452   4                  { InputPassword &= 0xFF0F;
1453   5                    InputPassword |= 0x0090;
1454   5                  }
1455   4                }
1456   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1457   3                {   System.BIT.BIT_01 = EQUAL_L;
1458   4                  DisplayStateIndex++;//下一项
1459   4                }
1460   3              break;
1461   3             case 0x02:
1462   3                Number_1_Display(1,19);
1463   3                if(System.BIT.BIT_06 == EQUAL_L)
1464   3                { Number_2_Display(2,(InputPassword >>8) &0x000F);    }
1465   3                else
1466   3                { Number_2_Display(2,19); }
1467   3                Number_3_Display(2,19);
1468   3                Number_4_Display(2,19);
1469   3                //---------------------------
1470   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1471   3                {   System.BIT.BIT_02 = EQUAL_L;
1472   4                  System.BIT.BIT_06 = EQUAL_L;
1473   4                  //-----------------------
1474   4                  if((InputPassword &0x0F00) < 0x0900)
1475   4                  { InputPassword += 0x0100;    }
1476   4                  else
1477   4                  { InputPassword &= 0xF0FF;    }
1478   4                }
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 25  

1479   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1480   3                {   System.BIT.BIT_03 = EQUAL_L;
1481   4                  System.BIT.BIT_06 = EQUAL_L;
1482   4                  //-----------------------
1483   4                  if((InputPassword &0x0F00) > 0x0000)
1484   4                  { InputPassword -= 0x0100;    }
1485   4                  else
1486   4                  { InputPassword &= 0xF0FF;
1487   5                    InputPassword |= 0x0900;
1488   5                  }
1489   4                }
1490   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1491   3                {   System.BIT.BIT_01 = EQUAL_L;
1492   4                  DisplayStateIndex++;//下一项
1493   4                }
1494   3              break;
1495   3             case 0x01:
1496   3                if(System.BIT.BIT_05 == EQUAL_L)
1497   3                  { Number_1_Display(2,(InputPassword >>12) &0x000F);   }
1498   3                  else
1499   3                  { Number_1_Display(2,19);   }
1500   3                  Number_2_Display(2,19);
1501   3                  Number_3_Display(2,19);
1502   3                  Number_4_Display(2,19);
1503   3                //---------------------------
1504   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1505   3                {   System.BIT.BIT_02 = EQUAL_L;
1506   4                  System.BIT.BIT_05 = EQUAL_L;
1507   4                  //-----------------------
1508   4                  if((InputPassword &0xF000) < 0x9000)
1509   4                  { InputPassword += 0x1000;    }
1510   4                  else
1511   4                  { InputPassword &= 0x0FFF;    }
1512   4                }
1513   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1514   3                {   System.BIT.BIT_03 = EQUAL_L;
1515   4                  System.BIT.BIT_05 = EQUAL_L;
1516   4                  //-----------------------
1517   4                  if((InputPassword &0xF000) > 0x0000)
1518   4                  { InputPassword -= 0x1000;    }
1519   4                  else
1520   4                  { InputPassword &= 0x0FFF;
1521   5                    InputPassword |= 0x9000;
1522   5                  }
1523   4                }
1524   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1525   3                {   System.BIT.BIT_01 = EQUAL_L;
1526   4                  DisplayStateIndex++;//下一项
1527   4                }
1528   3              break;
1529   3             default:
1530   3                System.BIT.BIT_04 = EQUAL_L;//正常设置不更改 密码
1531   3             case 0x40:
1532   3                ClearBitDisplay();
1533   3                DisplayStateIndex = 0x01;
1534   3                LCD_06.BIT.BIT_4 = EQUAL_H;//设置 图标
1535   3                //--------------------------------
1536   3                InputPassword = 0x5555;
1537   3                System.BIT.BIT_05 = EQUAL_H;
1538   3                System.BIT.BIT_06 = EQUAL_H;
1539   3                System.BIT.BIT_07 = EQUAL_H;
1540   3                System.BIT.BIT_08 = EQUAL_H;//密码标志位
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 26  

1541   3              break;
1542   3            }
1543   2          break;
1544   2         case 0x02://定时-开关机设定
1545   2            switch(DisplayStateIndex)
1546   2            {case 0x14://关机时间
1547   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1548   3                Temp_0 = AlaramTime[5] /10;
1549   3                Temp_1 = AlaramTime[5] %10;
1550   3                //--------------------------------------
1551   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1552   3                {   System.BIT.BIT_02 = EQUAL_L;
1553   4                  //-----------------------
1554   4                  if(++Temp_1 >9){  Temp_1 = 0;   }
1555   4                }
1556   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1557   3                {   System.BIT.BIT_03 = EQUAL_L;
1558   4                  //-----------------------
1559   4                  if(--Temp_1 <0){  Temp_1 = 9;   }
1560   4                }
1561   3                AlaramTime[5] = (Temp_0 *10) + Temp_1;
1562   3                //--------------------------------------
1563   3                Number_1_Display(1,AlaramTime[4] /10);
1564   3                Number_2_Display(1,AlaramTime[4] %10);
1565   3                Number_3_Display(1,AlaramTime[5] /10);
1566   3                Number_4_Display(2,AlaramTime[5] %10);//显示时间
1567   3                //--------------------------------------
1568   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1569   3                {   System.BIT.BIT_01 = EQUAL_L;
1570   4                  DisplaySetIndex++;//下一项
1571   4                  DisplayStateIndex = 0x00;
1572   4                }
1573   3              break;
1574   3             case 0x13:
1575   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1576   3                Temp_0 = AlaramTime[5] /10;
1577   3                Temp_1 = AlaramTime[5] %10;
1578   3                //--------------------------------------
1579   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1580   3                {   System.BIT.BIT_02 = EQUAL_L;
1581   4                  //-----------------------
1582   4                  if(++Temp_0 > 5){   Temp_0 = 0; }
1583   4                }
1584   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1585   3                {   System.BIT.BIT_03 = EQUAL_L;
1586   4                  //-----------------------
1587   4                  if(--Temp_0 < 0){   Temp_0 = 5; }
1588   4                }
1589   3                AlaramTime[5] = (Temp_0 *10) + Temp_1;
1590   3                //--------------------------------------
1591   3                Number_1_Display(1,AlaramTime[4] /10);
1592   3                Number_2_Display(1,AlaramTime[4] %10);
1593   3                Number_3_Display(2,AlaramTime[5] /10);
1594   3                Number_4_Display(1,AlaramTime[5] %10);//显示时间
1595   3                //--------------------------------------
1596   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1597   3                {   System.BIT.BIT_01 = EQUAL_L;
1598   4                  DisplayStateIndex++;//下一项
1599   4                }
1600   3              break;
1601   3             case 0x12:
1602   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 27  

1603   3                Temp_0 = AlaramTime[4] /10;
1604   3                Temp_1 = AlaramTime[4] %10;
1605   3                //--------------------------------------
1606   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1607   3                {   System.BIT.BIT_02 = EQUAL_L;
1608   4                  //-----------------------
1609   4                  if(++Temp_1 >9){  Temp_1 = 0;   }
1610   4                }
1611   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1612   3                {   System.BIT.BIT_03 = EQUAL_L;
1613   4                  //-----------------------
1614   4                  if(--Temp_1 <0){  Temp_1 = 9;   }
1615   4                }
1616   3                AlaramTime[4] = (Temp_0 *10) + Temp_1;
1617   3                //--------------------------------------
1618   3                Number_1_Display(1,AlaramTime[4] /10);
1619   3                Number_2_Display(2,AlaramTime[4] %10);
1620   3                Number_3_Display(1,AlaramTime[5] /10);
1621   3                Number_4_Display(1,AlaramTime[5] %10);//显示时间
1622   3                //--------------------------------------
1623   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1624   3                {   System.BIT.BIT_01 = EQUAL_L;
1625   4                  DisplayStateIndex++;//下一项
1626   4                }
1627   3              break;
1628   3             case 0x11:
1629   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1630   3                Temp_0 = AlaramTime[4] /10;
1631   3                Temp_1 = AlaramTime[4] %10;
1632   3                //--------------------------------------
1633   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1634   3                {   System.BIT.BIT_02 = EQUAL_L;
1635   4                  //-----------------------
1636   4                  if(++Temp_0 > 9){   Temp_0 = 0; }
1637   4                }
1638   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1639   3                {   System.BIT.BIT_03 = EQUAL_L;
1640   4                  //-----------------------
1641   4                  if(--Temp_0 < 0){   Temp_0 = 9; }
1642   4                }
1643   3                AlaramTime[4] = (Temp_0 *10) + Temp_1;
1644   3                //--------------------------------------
1645   3                Number_1_Display(2,AlaramTime[4] /10);
1646   3                Number_2_Display(1,AlaramTime[4] %10);
1647   3                Number_3_Display(1,AlaramTime[5] /10);
1648   3                Number_4_Display(1,AlaramTime[5] %10);//显示时间
1649   3                //--------------------------------------
1650   3                LCD_02.BIT.BIT_1 = EQUAL_H;//时间 秒点
1651   3                //--------------------------------------
1652   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1653   3                {   System.BIT.BIT_01 = EQUAL_L;
1654   4                  DisplayStateIndex++;//下一项
1655   4                }
1656   3              break;
1657   3             case 0x10://第二组
1658   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1659   3                //------------------------------------------
1660   3                Number_1_Display(1,2);
1661   3                Number_2_Display(0,0);
1662   3                if(AlaramTime[3] == 0x00)// OF
1663   3                { if(FlashDisplayTime <10)//秒 闪
1664   4                  { Number_3_Display(1,12);
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 28  

1665   5                    Number_4_Display(1,11);
1666   5                  }
1667   4                  else
1668   4                  { Number_3_Display(0,0);
1669   5                    Number_4_Display(0,0);
1670   5                  }
1671   4                }
1672   3                else
1673   3                { if(FlashDisplayTime <10)//秒 闪
1674   4                  { Number_3_Display(1,12);
1675   5                    Number_4_Display(1,13);
1676   5                  }
1677   4                  else
1678   4                  { Number_3_Display(0,0);
1679   5                    Number_4_Display(0,0);
1680   5                  }
1681   4                }
1682   3                //------------------------------------------
1683   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1684   3                {   System.BIT.BIT_02 = EQUAL_L;
1685   4                  //-----------------------
1686   4                  AlaramTime[3] = 0xAA;
1687   4                }
1688   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1689   3                {   System.BIT.BIT_03 = EQUAL_L;
1690   4                  //-----------------------
1691   4                  AlaramTime[3] = 0x00;
1692   4                }
1693   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1694   3                {   System.BIT.BIT_01 = EQUAL_L;
1695   4                  if(AlaramTime[3] != 0x00)
1696   4                  { DisplayStateIndex++;//下一项
1697   5                  }
1698   4                  else
1699   4                  { DisplaySetIndex++;
1700   5                    DisplayStateIndex = 0x00;
1701   5                  }
1702   4                }
1703   3              break;
1704   3             case 0x04://开机时间
1705   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1706   3                Temp_0 = AlaramTime[2] /10;
1707   3                Temp_1 = AlaramTime[2] %10;
1708   3                //--------------------------------------
1709   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1710   3                {   System.BIT.BIT_02 = EQUAL_L;
1711   4                  //-----------------------
1712   4                  if(++Temp_1 >9){  Temp_1 = 0;   }
1713   4                }
1714   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1715   3                {   System.BIT.BIT_03 = EQUAL_L;
1716   4                  //-----------------------
1717   4                  if(--Temp_1 <0){  Temp_1 = 9;   }
1718   4                }
1719   3                AlaramTime[2] = (Temp_0 *10) + Temp_1;
1720   3                //--------------------------------------
1721   3                Number_1_Display(1,AlaramTime[1] /10);
1722   3                Number_2_Display(1,AlaramTime[1] %10);
1723   3                Number_3_Display(1,AlaramTime[2] /10);
1724   3                Number_4_Display(2,AlaramTime[2] %10);//显示时间
1725   3                //--------------------------------------
1726   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 29  

1727   3                {   System.BIT.BIT_01 = EQUAL_L;
1728   4                  DisplayStateIndex = 0x10;//下一项
1729   4                  ClearBitDisplay();
1730   4                }
1731   3              break;
1732   3             case 0x03:
1733   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1734   3                Temp_0 = AlaramTime[2] /10;
1735   3                Temp_1 = AlaramTime[2] %10;
1736   3                //--------------------------------------
1737   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1738   3                {   System.BIT.BIT_02 = EQUAL_L;
1739   4                  //-----------------------
1740   4                  if(++Temp_0 > 5){   Temp_0 = 0; }
1741   4                }
1742   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1743   3                {   System.BIT.BIT_03 = EQUAL_L;
1744   4                  //-----------------------
1745   4                  if(--Temp_0 < 0){   Temp_0 = 5; }
1746   4                }
1747   3                AlaramTime[2] = (Temp_0 *10) + Temp_1;
1748   3                //--------------------------------------
1749   3                Number_1_Display(1,AlaramTime[1] /10);
1750   3                Number_2_Display(1,AlaramTime[1] %10);
1751   3                Number_3_Display(2,AlaramTime[2] /10);
1752   3                Number_4_Display(1,AlaramTime[2] %10);//显示时间
1753   3                //--------------------------------------
1754   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1755   3                {   System.BIT.BIT_01 = EQUAL_L;
1756   4                  DisplayStateIndex++;//下一项
1757   4                }
1758   3              break;
1759   3             case 0x02:
1760   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1761   3                Temp_0 = AlaramTime[1] /10;
1762   3                Temp_1 = AlaramTime[1] %10;
1763   3                //--------------------------------------
1764   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1765   3                {   System.BIT.BIT_02 = EQUAL_L;
1766   4                  //-----------------------
1767   4                  if(++Temp_1 >9){  Temp_1 = 0;   }
1768   4                }
1769   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1770   3                {   System.BIT.BIT_03 = EQUAL_L;
1771   4                  //-----------------------
1772   4                  if(--Temp_1 <0){  Temp_1 = 9;   }
1773   4                }
1774   3                AlaramTime[1] = (Temp_0 *10) + Temp_1;
1775   3                //--------------------------------------
1776   3                Number_1_Display(1,AlaramTime[1] /10);
1777   3                Number_2_Display(2,AlaramTime[1] %10);
1778   3                Number_3_Display(1,AlaramTime[2] /10);
1779   3                Number_4_Display(1,AlaramTime[2] %10);//显示时间
1780   3                //--------------------------------------
1781   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1782   3                {   System.BIT.BIT_01 = EQUAL_L;
1783   4                  DisplayStateIndex++;//下一项
1784   4                }
1785   3              break;
1786   3             case 0x01:
1787   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1788   3                Temp_0 = AlaramTime[1] /10;
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 30  

1789   3                Temp_1 = AlaramTime[1] %10;
1790   3                //--------------------------------------
1791   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1792   3                {   System.BIT.BIT_02 = EQUAL_L;
1793   4                  //-----------------------
1794   4                  if(++Temp_0 > 9){   Temp_0 = 0; }
1795   4                }
1796   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1797   3                {   System.BIT.BIT_03 = EQUAL_L;
1798   4                  //-----------------------
1799   4                  if(--Temp_0 < 0){   Temp_0 = 9; }
1800   4                }
1801   3                AlaramTime[1] = (Temp_0 *10) + Temp_1;
1802   3                //--------------------------------------
1803   3                Number_1_Display(2,AlaramTime[1] /10);
1804   3                Number_2_Display(1,AlaramTime[1] %10);
1805   3                Number_3_Display(1,AlaramTime[2] /10);
1806   3                Number_4_Display(1,AlaramTime[2] %10);//显示时间
1807   3                //--------------------------------------
1808   3                LCD_02.BIT.BIT_1 = EQUAL_H;//时间 秒点
1809   3                //--------------------------------------
1810   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1811   3                {   System.BIT.BIT_01 = EQUAL_L;
1812   4                  DisplayStateIndex++;//下一项
1813   4                }
1814   3              break;
1815   3             default:
1816   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1817   3                //------------------------------------------
1818   3                Number_1_Display(1,1);
1819   3                Number_2_Display(0,0);
1820   3                if(AlaramTime[0] == 0x00)// OF
1821   3                { if(FlashDisplayTime <10)//秒 闪
1822   4                  { Number_3_Display(1,12);
1823   5                    Number_4_Display(1,11);
1824   5                  }
1825   4                  else
1826   4                  { Number_3_Display(0,0);
1827   5                    Number_4_Display(0,0);
1828   5                  }
1829   4                }
1830   3                else
1831   3                { if(FlashDisplayTime <10)//秒 闪
1832   4                  { Number_3_Display(1,12);
1833   5                    Number_4_Display(1,13);
1834   5                  }
1835   4                  else
1836   4                  { Number_3_Display(0,0);
1837   5                    Number_4_Display(0,0);
1838   5                  }
1839   4                }
1840   3                //------------------------------------------
1841   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1842   3                {   System.BIT.BIT_02 = EQUAL_L;
1843   4                  //-----------------------
1844   4                  AlaramTime[0] = 0xAA;
1845   4                }
1846   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1847   3                {   System.BIT.BIT_03 = EQUAL_L;
1848   4                  //-----------------------
1849   4                  AlaramTime[0] = 0x00;
1850   4                }
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 31  

1851   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1852   3                {   System.BIT.BIT_01 = EQUAL_L;
1853   4                  if(AlaramTime[0] != 0x00)
1854   4                  { DisplayStateIndex++;    }//下一项
1855   4                  else
1856   4                  { DisplayStateIndex = 0x10; }
1857   4                }
1858   3              break;
1859   3            }
1860   2            break;
1861   2         case 0x01://预热时间设定
1862   2            switch(DisplayStateIndex)
1863   2            {case 0x02:
1864   3                Temp_0 = WorkingTime /10;
1865   3                Temp_1 = WorkingTime %10;
1866   3                //--------------------------------------
1867   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1868   3                {   System.BIT.BIT_02 = EQUAL_L;
1869   4                  //-----------------------
1870   4                  if(++Temp_1 >9){  Temp_1 = 0;   }
1871   4                }
1872   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1873   3                {   System.BIT.BIT_03 = EQUAL_L;
1874   4                  //-----------------------
1875   4                  if(--Temp_1 <0){  Temp_1 = 9;   }
1876   4                }
1877   3                WorkingTime = (Temp_0 *10) + Temp_1;
1878   3                //--------------------------------------
1879   3                Number_1_Display(1,15);
1880   3                Number_2_Display(1,19);
1881   3                Number_3_Display(1,WorkingTime /10);
1882   3                Number_4_Display(2,WorkingTime %10);//显示时间
1883   3                //--------------------------------------
1884   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1885   3                {   System.BIT.BIT_01 = EQUAL_L;
1886   4                  DisplaySetIndex++;//下一项
1887   4                  DisplayStateIndex = 0x00;
1888   4                  ClearBitDisplay();
1889   4                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1890   4                }
1891   3              break;
1892   3             case 0x01:
1893   3                Temp_0 = WorkingTime /10;
1894   3                Temp_1 = WorkingTime %10;
1895   3                //--------------------------------------
1896   3                if(System.BIT.BIT_02 == EQUAL_H)//上调
1897   3                {   System.BIT.BIT_02 = EQUAL_L;
1898   4                  //-----------------------
1899   4                  if(++Temp_0 > 9){   Temp_0 = 0; }
1900   4                }
1901   3                if(System.BIT.BIT_03 == EQUAL_H)//下调
1902   3                {   System.BIT.BIT_03 = EQUAL_L;
1903   4                  //-----------------------
1904   4                  if(--Temp_0 < 0){   Temp_0 = 9; }
1905   4                }
1906   3                WorkingTime = (Temp_0 *10) + Temp_1;
1907   3                //--------------------------------------
1908   3                Number_1_Display(1,15);
1909   3                Number_2_Display(1,19);
1910   3                Number_3_Display(2,WorkingTime /10);
1911   3                Number_4_Display(1,WorkingTime %10);//显示时间
1912   3                //--------------------------------------
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 32  

1913   3                if(System.BIT.BIT_01 == EQUAL_H)//确认
1914   3                {   System.BIT.BIT_01 = EQUAL_L;
1915   4                  DisplayStateIndex++;//下一项
1916   4                }
1917   3              break;
1918   3             default:
1919   3                ClearBitDisplay();
1920   3                LCD_05.BIT.BIT_2 = EQUAL_H;//闹钟图标
1921   3                DisplayStateIndex++;//下一项
1922   3              break;
1923   3            }
1924   2          break;
1925   2         default:////轮流显示--时间，当前环境温度
1926   2            ClearBitDisplay();
1927   2            //--------------------------------------------------
1928   2            switch(DisplayStateIndex)
1929   2            {
1930   3             case 0x05://故障码显示
1931   3                int_Temp_1 = RotateSpeed.Data;//显示转速
1932   3                if(int_Temp_1 >9999){ int_Temp_1 = 9999;  }//防止显示溢出
1933   3                //--------------------------------------------
1934   3                Number_1_Display(1,int_Temp_1 /1000);
1935   3                int_Temp_1 %= 1000;
1936   3                Number_2_Display(1,int_Temp_1 /100);
1937   3                int_Temp_1 %= 100;
1938   3                Number_3_Display(1,int_Temp_1 /10);
1939   3                Number_4_Display(1,int_Temp_1 %10);
1940   3                
1941   3                LCD_00.BIT.BIT_6 = EQUAL_H;//转速 RPM
1942   3              break;
1943   3             case 0x04://海拔高度
1944   3                if(AvgAltitude.Data & 0x80000000)//负值，补码转换
1945   3                { int_Temp_1 = (~AvgAltitude.Data +1) &0x00FFFFFF;
1946   4                  Temp_0 = 0x01;//负数标志
1947   4                  Number_1_Display(1,19);//显示 负号
1948   4                }
1949   3                else
1950   3                { int_Temp_1 = AvgAltitude.Data;
1951   4                  Temp_0 = 0x00;
1952   4                }
1953   3                //-----------------------------------
1954   3                if(int_Temp_1 <10000)//显示小数
1955   3                { int_Temp_1 = int_Temp_1 /10;//海拔高度
1956   4                  int_Temp_2 = int_Temp_1;//备份
1957   4                  if(Temp_0 == 0x00)
1958   4                  { if(int_Temp_2 >999)
1959   5                    { Number_1_Display(1,int_Temp_1 /1000); }
1960   5                    else
1961   5                    { Number_1_Display(0,0);    }
1962   5                  }
1963   4                  //---------------------------
1964   4                  int_Temp_1 %= 1000;
1965   4                  if(int_Temp_2 >99)
1966   4                  { Number_2_Display(1,int_Temp_1 /100);  }
1967   4                  else
1968   4                  { Number_2_Display(0,0);    }
1969   4                  //---------------------------
1970   4                  int_Temp_1 %= 100;
1971   4                  Number_3_Display(1,int_Temp_1 /10);
1972   4                  Number_4_Display(1,int_Temp_1 %10);
1973   4                  //---------------------------
1974   4                  LCD_02.BIT.BIT_4 = EQUAL_H;//3 下点
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 33  

1975   4                }
1976   3                else
1977   3                { int_Temp_1 = int_Temp_1 /100;//海拔高度
1978   4                  int_Temp_2 = int_Temp_1;//备份
1979   4                  if(Temp_0 == 0x00)
1980   4                  { if(int_Temp_2 >999)
1981   5                    { Number_1_Display(1,int_Temp_1 /1000); }
1982   5                    else
1983   5                    { Number_1_Display(0,0);    }
1984   5                  }
1985   4                  //---------------------------
1986   4                  int_Temp_1 %= 1000;
1987   4                  if(int_Temp_2 >99)
1988   4                  { Number_2_Display(1,int_Temp_1 /100);  }
1989   4                  else
1990   4                  { Number_2_Display(0,0);    }
1991   4                  //---------------------------
1992   4                  int_Temp_1 %= 100;
1993   4                  Number_3_Display(1,int_Temp_1 /10);
1994   4                  Number_4_Display(1,int_Temp_1 %10);
1995   4                  //---------------------------
1996   4                  LCD_02.BIT.BIT_4 = EQUAL_H;//3 下点
1997   4                }
1998   3                LCD_09.BIT.BIT_4 = EQUAL_H;//海拔高度
1999   3                LCD_00.BIT.BIT_2 = EQUAL_H;//海拔高度 m
2000   3              break;
2001   3             case 0x03://工作电压
2002   3                int_Temp_1 = RunVoltage.Data;
2003   3                if(int_Temp_1 >999){  int_Temp_1 =999;  }
2004   3                //---------------------------
2005   3                Number_1_Display(0,0);//关闭
2006   3                Number_2_Display(1,int_Temp_1 /100);
2007   3                int_Temp_1 %= 100;
2008   3                Number_3_Display(1,int_Temp_1 /10);
2009   3                //---------------------------
2010   3                Number_4_Display(1,int_Temp_1 %10);
2011   3                //---------------------------
2012   3                LCD_02.BIT.BIT_4 = EQUAL_H;//3 下点
2013   3                LCD_00.BIT.BIT_7 = EQUAL_H;//电压 图标
2014   3              break;
2015   3             case 0x02://显示工作档位
2016   3                if(Config.Struct.TemperatureType == 0x01)//控温方式
2017   3                { Number_1_Display(1,21);
2018   4                  Number_2_Display(1,19);
2019   4                  Number_3_Display(1,Config.Struct.EnergyLevel /10);
2020   4                  Number_4_Display(1,Config.Struct.EnergyLevel %10);
2021   4                }
2022   3                else//显示剩余工作时间
2023   3                { Number_1_Display(1,10);// H
2024   4                  Number_2_Display(2,19);// -
2025   4                //--------------------------------------------
2026   4                  Number_3_Display(1,RemainingWorkingTime /10);
2027   4                  Number_4_Display(1,RemainingWorkingTime %10);
2028   4                }
2029   3             
2030   3              break;
2031   3             case 0x01://环境温度
2032   3                if(HY.Temperature <0)
2033   3                { int_Temp_1 = (0 - HY.Temperature);//温度显示
2034   4                  Number_1_Display(1,0x13);//显示负号
2035   4                }
2036   3                else
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 34  

2037   3                { int_Temp_1 = HY.Temperature;//温度显示
2038   4                  if(int_Temp_1 >99)
2039   4                  { Number_1_Display(1,int_Temp_1 /100);  }
2040   4                  else
2041   4                  { Number_1_Display(0,0);    }
2042   4                  int_Temp_1 %= 100;
2043   4                }
2044   3                Number_2_Display(1,int_Temp_1 /10);
2045   3                Number_3_Display(1,int_Temp_1 %10);
2046   3                Number_4_Display(1,15);
2047   3                //---------------------------
2048   3                LCD_03.BIT.BIT_4 = EQUAL_H;//温度上点
2049   3      //          LCD_00.BIT.BIT_1 = EQUAL_H;//火焰温度 图标
2050   3             
2051   3              break;
2052   3             default:////时钟显示
2053   3                if(ErrorIndex > 0x01)
2054   3                { int_Temp_1 = ErrorIndex -0x01;//显示错误状态
2055   4                  Number_1_Display(1,0x12);// E
2056   4                  Number_2_Display(2,0x13);// - //闪烁
2057   4                  Number_3_Display(1,int_Temp_1 /10);
2058   4                  Number_4_Display(1,int_Temp_1 %10);
2059   4                }
2060   3                else//壳体温度、开关机显示
2061   3                { if(SW.Temperature <0)
2062   4                  { int_Temp_1 = (0 - SW.Temperature);//温度显示
2063   5                    Number_1_Display(1,0x13);//显示负号
2064   5                  }
2065   4                  else
2066   4                  { int_Temp_1 = SW.Temperature;//温度显示
2067   5                    if(int_Temp_1 >99)
2068   5                    { Number_1_Display(1,int_Temp_1 /100);  }
2069   5                    else
2070   5                    { Number_1_Display(0,0);    }
2071   5                    int_Temp_1 %= 100;
2072   5                  }
2073   4                  Number_2_Display(1,int_Temp_1 /10);
2074   4                  Number_3_Display(1,int_Temp_1 %10);
2075   4                  Number_4_Display(1,15);
2076   4                //---------------------------
2077   4                  LCD_03.BIT.BIT_4 = EQUAL_H;//温度上点
2078   4                  LCD_00.BIT.BIT_3 = EQUAL_H;
2079   4      //            LCD_00.BIT.BIT_2 = EQUAL_H;//水温温度 图标
2080   4                }
2081   3              break;
2082   3            }
2083   2                  //-----------------------------------
2084   2            if((AlaramTime[0] != 0x00)||(AlaramTime[3] != 0x00))
2085   2            { LCD_05.BIT.BIT_2 = EQUAL_H;   }//定时 闹钟
2086   2            else
2087   2            { LCD_05.BIT.BIT_2 = EQUAL_L;   }
2088   2                  //-----------------------------------
2089   2            DisplaySetIndex = 0x00;
2090   2          break;
2091   2        }
2092   1          //---------------------------------------------------------------
2093   1        LCD_04.BIT.BIT_7 = EQUAL_H;////飘带 线条
2094   1        RunStateDisplay();//实时显示运行状态
2095   1      }
2096          //-----------------------------------------------------------------------------
2097          void LCD_DisplayUpdate(void)
2098          { switch(DisplayIndex++)
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 35  

2099   1        {
2100   2        case 0x03:
2101   2            LCD_WriteLram(0x02,LCD_01.DATA &0x0F);
2102   2            LCD_WriteLram(0x03,LCD_01.DATA >>4);
2103   2            LCD_WriteLram(0x04,LCD_02.DATA &0x0F);
2104   2            LCD_WriteLram(0x05,LCD_02.DATA >>4);
2105   2            LCD_WriteLram(0x0E,LCD_07.DATA &0x0F);
2106   2            LCD_WriteLram(0x0F,LCD_07.DATA >>4);
2107   2        case 0x02:
2108   2      
2109   2            LCD_WriteLram(0x10,LCD_08.DATA &0x0F);
2110   2            LCD_WriteLram(0x11,LCD_08.DATA >>4);
2111   2            LCD_WriteLram(0x12,LCD_09.DATA &0x0F);
2112   2            LCD_WriteLram(0x13,LCD_09.DATA >>4);
2113   2      
2114   2          break;
2115   2         case 0x01:
2116   2            LCD_WriteLram(0x06,LCD_03.DATA &0x0F);
2117   2            LCD_WriteLram(0x07,LCD_03.DATA >>4);
2118   2            LCD_WriteLram(0x08,LCD_04.DATA &0x0F);
2119   2            LCD_WriteLram(0x09,LCD_04.DATA >>4);
2120   2            LCD_WriteLram(0x0A,LCD_05.DATA &0x0F);
2121   2            LCD_WriteLram(0x0B,LCD_05.DATA >>4);
2122   2          break;
2123   2         default:
2124   2            LCD_WriteLram(0x0C,LCD_06.DATA &0x0F);
2125   2            LCD_WriteLram(0x0D,LCD_06.DATA >>4);
2126   2            LCD_WriteLram(0x00,LCD_00.DATA &0x0F);
2127   2            LCD_WriteLram(0x01,LCD_00.DATA >>4);
2128   2            DisplayIndex = 0x01;
2129   2          break;
2130   2        }
2131   1        
2132   1        
2133   1        
2134   1      }
2135          
2136          void Display_Test(void)
2137          {
2138   1        LCD_00.DATA = 0xFF;
2139   1        LCD_01.DATA = 0xFF;
2140   1        LCD_02.DATA = 0xFF;
2141   1        LCD_03.DATA = 0xFF;
2142   1        LCD_04.DATA = 0xFF;
2143   1        LCD_05.DATA = 0xFF;
2144   1        LCD_06.DATA = 0xFF;
2145   1        LCD_07.DATA = 0xFF;
2146   1        LCD_08.DATA = 0xFF;
2147   1        LCD_09.DATA = 0xFF;
2148   1      
2149   1        
2150   1            LCD_WriteLram(0x00,LCD_00.DATA &0x0F);
2151   1            LCD_WriteLram(0x01,LCD_00.DATA >>4);
2152   1            LCD_WriteLram(0x02,LCD_01.DATA &0x0F);
2153   1            LCD_WriteLram(0x03,LCD_01.DATA >>4);
2154   1            LCD_WriteLram(0x04,LCD_02.DATA &0x0F);
2155   1            LCD_WriteLram(0x05,LCD_02.DATA >>4);
2156   1            LCD_WriteLram(0x06,LCD_03.DATA &0x0F);
2157   1            LCD_WriteLram(0x07,LCD_03.DATA >>4);
2158   1            LCD_WriteLram(0x08,LCD_04.DATA &0x0F);
2159   1            LCD_WriteLram(0x09,LCD_04.DATA >>4);
2160   1            LCD_WriteLram(0x0A,LCD_05.DATA &0x0F);
C51 COMPILER V9.01   DISPLAYPROCESS                                                        07/25/2024 09:04:08 PAGE 36  

2161   1            LCD_WriteLram(0x0B,LCD_05.DATA >>4);
2162   1            LCD_WriteLram(0x0C,LCD_06.DATA &0x0F);
2163   1            LCD_WriteLram(0x0D,LCD_06.DATA >>4);
2164   1            LCD_WriteLram(0x0E,LCD_07.DATA &0x0F);
2165   1            LCD_WriteLram(0x0F,LCD_07.DATA >>4);
2166   1            LCD_WriteLram(0x10,LCD_08.DATA &0x0F);
2167   1            LCD_WriteLram(0x11,LCD_08.DATA >>4);
2168   1            LCD_WriteLram(0x12,LCD_09.DATA &0x0F);
2169   1            LCD_WriteLram(0x13,LCD_09.DATA >>4);
2170   1      
2171   1      
2172   1      
2173   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10939    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =     50      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
