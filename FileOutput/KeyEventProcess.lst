C51 COMPILER V9.01   KEYEVENTPROCESS                                                       07/25/2024 08:55:30 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE KEYEVENTPROCESS
OBJECT MODULE PLACED IN .\FileOutput\KeyEventProcess.obj
COMPILER INVOKED BY: D:\software\keil\C51\BIN\C51.EXE SourceFile\KeyEventProcess.C LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE I
                    -NCDIR(.\ConfigFile;.\CMT2300A) DEBUG PRINT(.\FileOutput\KeyEventProcess.lst) TABS(2) OBJECT(.\FileOutput\KeyEventProcess
                    -.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          //功能说明：按键处理
   3          //-----------------------------------------------------------------------------
   4          #include <intrins.h>
   5          #include "ca51f_config.h"
   6          #include "ca51f2sfr.h"
   7          #include "ca51f2xsfr.h"
   8          #include "gpiodef_f2.h"
   9          #include "system.h"
  10          
  11          #include "flash.h"
  12          #include "WT588Fxx.h"
  13          #include "KeyEvent.H"
  14          #include "DisplayUpdata.H"
  15          
  16          
  17          #ifdef Enable_CMT2300 //打开双向遥控
  18            #include "Radio.H"
  19          #endif
  20          
  21          //-----------------------------------------------------------------------------
  22          xdata unsigned char ExitSetupTime;//退出设置计时
  23          
  24          xdata unsigned char KeyState;
  25          xdata unsigned char KeyEvent;
  26          xdata unsigned int KeyCount_Time;//长按计时
  27          xdata unsigned char KeyTimeLimit;
  28          xdata unsigned char KeyEventCount;
  29          //--------------------------------------------------------------
  30          xdata union {
  31            unsigned char DATA;
  32            struct{
  33              unsigned char BIT_01:1;//确认
  34              unsigned char BIT_02:1;//上调
  35              unsigned char BIT_03:1;//下调
  36              unsigned char BIT_04:1;//修改密码
  37              unsigned char BIT_05:1;//密码 个位
  38              unsigned char BIT_06:1;//密码 十位
  39              unsigned char BIT_07:1;//密码 百位
  40              unsigned char BIT_08:1;//密码 千位
  41            }BIT;
  42          }System;
  43          
  44          xdata unsigned char DataChangeUpdataTime;
  45          xdata unsigned char OilpumpEnableState;//允许泵油条件
  46          //-----------------------------------------------------------------------------
  47          //P54 开机  0x10  0xEF
  48          //P53 设置  0x08  0xF7
  49          //P52 确定  0x04  0xFB
  50          //P51 上调  0x02  0xFD
  51          //P50 下调  0x01  0xF3
  52          void KeyStateScan(void)
  53          {unsigned char KeyPortState = 0xFF;
C51 COMPILER V9.01   KEYEVENTPROCESS                                                       07/25/2024 08:55:30 PAGE 2   

  54   1        if(P54 == 0){ KeyPortState &= 0xFE; } //FE = 开关，
  55   1        if(P50 == 0){ KeyPortState &= 0xFD; } //FB = 下调
  56   1        if(P51 == 0){ KeyPortState &= 0xFB; } //FD = 上调，
  57   1        if(P53 == 0){ KeyPortState &= 0xFC; } //FC = 设置
  58   1        if(P52 == 0){ KeyPortState &= 0xFA; } //FA = 确定
  59   1      
  60   1        if(KeyEvent != KeyPortState)
  61   1        { if(++KeyCount_Time >KEY_HOLDTIME)
  62   2          { KeyEvent = KeyPortState;
  63   3      
  64   3            if(KeyEvent == 0xFA)
  65   3            { KeyEventCount++;//连续短按计数
  66   4              KeyTimeLimit = 200;//750毫秒
  67   4            }
  68   3          }
  69   2        }
  70   1        else
  71   1        { //  开机键
  72   2          if((KeyEvent == 0xFE)|| (KeyEvent == 0xFB) || (KeyEvent == 0xFD))
  73   2          { if((KeyCount_Time < KeyCount_HOLD)&&(DisplaySetIndex == 0x00))    //
  74   3            { if(++KeyCount_Time ==KeyCount_HOLD)
  75   4              { KeyState = 0xFF;  
  76   5              }//处理长按
  77   4            }
  78   3          }
  79   2          else if((KeyEvent == 0xFC) )
  80   2          {
  81   3            if(KeyCount_Time < KeyCount_HOLD)   //
  82   3            { if(++KeyCount_Time ==KeyCount_HOLD)
  83   4              { KeyState = 0xFF;  
  84   5              }//处理长按
  85   4            }
  86   3          }
  87   2          else//按键释放后，才检测 短按次数
  88   2          { KeyCount_Time = 0x00;
  89   3          //-------------------------------------------------
  90   3            if(KeyTimeLimit >0)//快速连续 短按计数
  91   3            { if(--KeyTimeLimit == 0x00)
  92   4              { 
  93   5                if(KeyEventCount ==1)//确认键
  94   5                { KeyEvent = 0xF2;  KeyState = 0xFF;  }
  95   5                else if((KeyEventCount ==2)&&(DisplaySetIndex == 0x00))
  96   5                { KeyEvent = 0xF5;  KeyState = 0xFF;  }   //控温模式
  97   5                
  98   5                else if((KeyEventCount ==3)&&(DisplaySetIndex == 0x00))//开启水泵
  99   5                { KeyEvent = 0xF3;  KeyState = 0xFF;  }//等同于长按
 100   5      //          else if((KeyEventCount ==4))//进入设置
 101   5      //          { KeyEvent = 0xF4;  KeyState = 0xFF;  }
 102   5      //          else if((KeyEventCount ==5)&&(DisplaySetIndex == 0x00))//控温方式
 103   5      //          { KeyEvent = 0xF5;  KeyState = 0xFF;  }
 104   5                KeyEventCount = 0x00;
 105   5              }
 106   4            }
 107   3          }
 108   2        }
 109   1      }
 110          //-----------------------------------------------------------------------------
 111          void KeyEventProcess(void)
 112          { if((SystemRunState >=TASK_RapidWarming)&&(SW.Temperature >50))
 113   1        { OilpumpEnableState = 0x00;    }//正常开机,检测到温升后禁止手动泵油
 114   1        //--------------------------------------
 115   1        if(KeyState != KeyEvent)
C51 COMPILER V9.01   KEYEVENTPROCESS                                                       07/25/2024 08:55:30 PAGE 3   

 116   1        { KeyState = KeyEvent;//单次执行
 117   2          BackLightTime = 500;//设置背光高亮时间
 118   2        //--------------------------------------
 119   2          if(KeyCount_Time >= KeyCount_HOLD)//长按键处理
 120   2          { switch(KeyEvent)
 121   3            {case 0xFE://开关机
 122   4                if(SystemRunState == TASK_IdleMode)//ON
 123   4                { if(((RunVoltage.Data >100)&&(RunVoltage.Data <170))
 124   5                   ||((RunVoltage.Data >190)&&(RunVoltage.Data <320)))//电压限制
 125   5                  { SystemRunIndex = URAT_PowerOn;    }//启动
 126   5                }
 127   4                else
 128   4                { SystemRunIndex = UART_PowerOff;   }//关闭
 129   4              break;
 130   4      
 131   4             case 0xFB://遥控对码//下调
 132   4                if(SystemRunState == TASK_IdleMode)
 133   4                { if(DisplaySetIndex != 0x0C)
 134   5                  { DisplaySetIndex = 0x0C;
 135   6                    DisplayStateIndex = 0x00;
 136   6                    ExitSetupTime = 0;
 137   6                  }//禁止按键超时退出，遥控学习时间超时才退出
 138   5                }
 139   4              break;
 140   4             case 0xFD://手动泵油//上调
 141   4                if((SystemRunState == TASK_IdleMode)&&(OilpumpEnableState == 0xAA))
 142   4                { if(DisplaySetIndex != 0x0D)
 143   5                  { DisplayStateIndex = 0x00;
 144   6                    DisplaySetIndex = 0x0D;
 145   6                    ExitSetupTime = 00;//以秒为单位（禁止自动退出）
 146   6                  }
 147   5                }
 148   4              break;
 149   4                
 150   4      
 151   4      
 152   4             case 0xFC: //退出设置
 153   4               if((DisplaySetIndex > 0x00 && DisplaySetIndex < 0x09) || (DisplaySetIndex >= 0x0C && DisplaySetIndex 
             -< 0x0D))
 154   4               {
 155   5                 DisplaySetIndex = 0x00;  
 156   5                 DisplayStateIndex = 0x00;
 157   5               }
 158   4               else if(DisplaySetIndex == 0x0E)
 159   4               {
 160   5                 DisplayStateIndex++;
 161   5               }
 162   4               else if(DisplaySetIndex == 0x0D)
 163   4               {
 164   5                 System.BIT.BIT_01 = EQUAL_H;
 165   5               }
 166   4               break;
 167   4            }
 168   3          }
 169   2          else//----------------------------短按键处理
 170   2          { switch(KeyEvent)
 171   3            {case 0xFB://下调 
 172   4                if(DisplaySetIndex == 0x00)
 173   4                { if(Config.Struct.EnergyLevel >1)//输出功率 0-9 共10级
 174   5                  {   Config.Struct.EnergyLevel--;
 175   6                    DataChangeUpdataTime = 6;//设定参数回存时间
 176   6                  }
C51 COMPILER V9.01   KEYEVENTPROCESS                                                       07/25/2024 08:55:30 PAGE 4   

 177   5                  DisplayStateIndex = 0x02;//显示设定温度
 178   5                  ExitSetupTime = 3;//以秒为单位
 179   5                  
 180   5                //------------------------------------------
 181   5              #ifdef Enable_CMT2300 //打开双向遥控
 182   5                  if((Config.Struct.RF_Address.DATA != 0x00000000) && (Config.Struct.RF_Address.DATA != 0xFFFFFFFF))
 183   5                  { CMT2300_T_Array[0] =0xAA; }//准备发送数据
 184   5              #endif
 185   5                }
 186   4                else
 187   4                {   
 188   5                  System.BIT.BIT_01 = EQUAL_L;
 189   5                  System.BIT.BIT_02 = EQUAL_L;
 190   5                  //--------------------
 191   5                  System.BIT.BIT_03 = EQUAL_H;
 192   5                  FlashDisplayTime = 0x00;
 193   5                  ExitSetupTime = 15;//以秒为单位
 194   5                }//参数 下调
 195   4              break;
 196   4             case 0xFD://上调 0xF7
 197   4                if(DisplaySetIndex == 0x00)
 198   4                { if(Config.Struct.EnergyLevel <9)//输出功率 0-9 共10级
 199   5                  {   Config.Struct.EnergyLevel++;
 200   6                    DataChangeUpdataTime = 6;//设定参数回存时间
 201   6                  }
 202   5                  DisplayStateIndex = 0x02;//显示设定温度
 203   5                  ExitSetupTime = 3;//以秒为单位
 204   5                  
 205   5                //------------------------------------------
 206   5              #ifdef Enable_CMT2300 //打开双向遥控
 207   5                  if((Config.Struct.RF_Address.DATA != 0x00000000) && (Config.Struct.RF_Address.DATA != 0xFFFFFFFF))
 208   5                  { CMT2300_T_Array[0] =0xAA; }//准备发送数据
 209   5              #endif
 210   5                }
 211   4                else
 212   4                {   
 213   5                  System.BIT.BIT_01 = EQUAL_L;
 214   5                  System.BIT.BIT_03 = EQUAL_L;
 215   5                  //--------------------
 216   5                  System.BIT.BIT_02 = EQUAL_H;
 217   5                  FlashDisplayTime = 0x00;
 218   5                  ExitSetupTime = 15;//以秒为单位
 219   5                }//上调
 220   4              break;
 221   4             case 0xF2://确认 0xFD
 222   4                if(DisplaySetIndex == 0x00)
 223   4                {   if(++DisplayStateIndex >4)
 224   5                  {   DisplayStateIndex = 0x00;
 225   6                  }
 226   5                  ExitSetupTime = 00;//以秒为单位（禁止自动退出）
 227   5                }
 228   4                else
 229   4                {   
 230   5                  System.BIT.BIT_02 = EQUAL_L;
 231   5                  System.BIT.BIT_03 = EQUAL_L;
 232   5                  //--------------------
 233   5                  System.BIT.BIT_01 = EQUAL_H;
 234   5                  ExitSetupTime = 15;//以秒为单位
 235   5                //------------------------------------------
 236   5              #ifdef Enable_CMT2300 //打开双向遥控
 237   5                if(Config.Struct.RF_Address.DATA != 0xFFFFFFFF)
 238   5                { CMT2300_T_Array[0] =0xAA; }//准备发送数据
C51 COMPILER V9.01   KEYEVENTPROCESS                                                       07/25/2024 08:55:30 PAGE 5   

 239   5              #endif
 240   5                }//确认
 241   4      
 242   4              break;
 243   4                
 244   4             case 0xF4://设置 0xEF
 245   4      
 246   4                  if(++DisplaySetIndex >7)
 247   4                  {   DisplaySetIndex = 0x00;
 248   5                    InputPassword = 0x0000;
 249   5                  }
 250   4                  if(Config.Struct.Password.DATA != InputPassword)
 251   4                  { if(DisplaySetIndex >3)
 252   5                    { DisplaySetIndex = 0x00;   }
 253   5                  } 
 254   4                  DisplayStateIndex = 0x00;
 255   4                System.BIT.BIT_01 = EQUAL_L;
 256   4                System.BIT.BIT_02 = EQUAL_L;
 257   4                System.BIT.BIT_03 = EQUAL_L;
 258   4                ExitSetupTime = 15;//以秒为单位
 259   4              break;
 260   4             case 0xF5://控温方式选择
 261   4                if(Config.Struct.TemperatureType == 0x02)//改变控温方式
 262   4                { Config.Struct.TemperatureType = 0x01; }
 263   4                else
 264   4                { Config.Struct.TemperatureType = 0x02; }
 265   4                DataChangeUpdataTime = 6;//设定参数回存时间
 266   4                //-----------------------------------------
 267   4                DisplayStateIndex = 0x02;//显示设定温度
 268   4                ExitSetupTime = 3;//以秒为单位
 269   4              break;
 270   4                
 271   4             case 0xF3://开启水泵//连续 短按 3次
 272   4                if(SystemRunState == TASK_IdleMode)
 273   4                { if(DisplaySetIndex != 0x0E)
 274   5                  { DisplaySetIndex = 0x0E;
 275   6                    DisplayStateIndex = 0x00;
 276   6                    ExitSetupTime = 0;
 277   6                  }//禁止按键超时退出
 278   5                }
 279   4              break;
 280   4                
 281   4            case 0xFC:    //进入设置
 282   4              if(DisplaySetIndex >= 0x01 && DisplaySetIndex < 0x03)
 283   4              {
 284   5                DisplaySetIndex ++;
 285   5                DisplayStateIndex = 0x00;
 286   5              }
 287   4              else if(DisplaySetIndex == 0x00)
 288   4              {
 289   5                DisplaySetIndex = 0x01;
 290   5                DisplayStateIndex = 0x00;
 291   5                ExitSetupTime = 15;
 292   5              }
 293   4               break;
 294   4            }
 295   3          }
 296   2        }
 297   1      }
 298          


C51 COMPILER V9.01   KEYEVENTPROCESS                                                       07/25/2024 08:55:30 PAGE 6   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1132    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
